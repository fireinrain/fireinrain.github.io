<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>volatile为什么不能保证原子性</title>
    <url>/2020/02/01/volatile%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7/</url>
    <content><![CDATA[<h1 id="volatile为什么不能保证原子性"><a href="#volatile为什么不能保证原子性" class="headerlink" title="volatile为什么不能保证原子性"></a>volatile为什么不能保证原子性</h1><p>在看《大型网站系统和Java中间件实践》的时候，在第三章有个疑惑：synchronized 可以保证多线程下的互斥和多线程下的内存可见性。用volatile 修饰的属性值也是可以保证多线程下的内存可见性，但是为啥单用volatile修饰在多线程下就会出现问题呢？</p>
<p>首先要了解的是，volatile可以保证可见性和顺序性，这些都很好理解，那么它为什么不能保证原子性呢？</p>
<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>可见性与Java的内存模型有关，模型采用缓存与主存的方式对变量进行操作，也就是说，每个线程都有自己的缓存空间，对变量的操作都是在缓存中进行的，之后再将修改后的值返回到主存中，这就带来了问题，有可能一个线程在将共享变量修改后，还没有来的及将缓存中的变量返回给主存中，另外一个线程就对共享变量进行修改，那么这个线程拿到的值是主存中未被修改的值，这就是可见性的问题。</p>
<p>volatile很好的保证了变量的可见性，变量经过volatile修饰后，对此变量进行写操作时，汇编指令中会有一个LOCK前缀指令，这个不需要过多了解，但是加了这个指令后，会引发两件事情：</p>
<p>将当前处理器缓存行的数据写回到系统内存<br>这个写回内存的操作会使得在其他处理器缓存了该内存地址无效<br>什么意思呢？意思就是说当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值，这就保证了可见性。</p>
<h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>问题来了，既然它可以保证修改的值立即能更新到主存，其他线程也会捕捉到被修改后的值，那么为什么不能保证原子性呢？<br>首先需要了解的是，Java中只有对基本类型变量的赋值和读取是原子操作，如i = 1的赋值操作，但是像j = i或者i++这样的操作都不是原子操作，因为他们都进行了多次原子操作，比如先读取i的值，再将i的值赋值给j，两个原子操作加起来就不是原子操作了。</p>
<p>所以，如果一个变量被volatile修饰了，那么肯定可以保证每次读取这个变量值的时候得到的值是最新的，但是一旦需要对变量进行自增这样的非原子操作，就不会保证这个变量的原子性了。</p>
<p>举个栗子</p>
<p>一个变量i被volatile修饰，两个线程想对这个变量修改，都对其进行自增操作也就是i++，i++的过程可以分为三步，首先获取i的值，其次对i的值进行加1，最后将得到的新值写会到缓存中。<br>线程A首先得到了i的初始值100，但是还没来得及修改，就阻塞了，这时线程B开始了，它也得到了i的值，由于i的值未被修改，即使是被volatile修饰，主存的变量还没变化，那么线程B得到的值也是100，之后对其进行加1操作，得到101后，将新值写入到缓存中，再刷入主存中。根据可见性的原则，这个主存的值可以被其他线程可见。<br>问题来了，线程A已经读取到了i的值为100，也就是说读取的这个原子操作已经结束了，所以这个可见性来的有点晚，线程A阻塞结束后，继续将100这个值加1，得到101，再将值写到缓存，最后刷入主存，所以即便是volatile具有可见性，也不能保证对它修饰的变量具有原子性。</p>
<p><img src="/2020/02/01/volatile%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7/image-20200201214033793.png" alt="image-20200201214033793"></p>
<p>原文转载自：<a href="https://blog.csdn.net/xdzhouxin/article/details/81236356" target="_blank" rel="noopener">https://blog.csdn.net/xdzhouxin/article/details/81236356</a></p>
<hr>
<h1 id="为什么volatile不能保证原子性"><a href="#为什么volatile不能保证原子性" class="headerlink" title="为什么volatile不能保证原子性"></a>为什么volatile不能保证原子性</h1><p>为什么volatile能替代简单的锁，却不能保证原子性？这里面涉及volatile，是java中的一个我觉得这个词在Java规范中从未被解释清楚的神奇关键词，在Sun的JDK官方文档是这样形容volatile的：</p>
<p>The Java programming language provides a second mechanism, volatile fields, that is more convenient than locking for some purposes. A field may be declared volatile, in which case the Java Memory Model ensures that all threads see a consistent value for the variable.</p>
<p>意思就是说，如果一个变量加了volatile关键字，就会告诉编译器和JVM的内存模型：这个变量是对所有线程共享的、可见的，每次jvm都会读取最新写入的值并使其最新值在所有CPU可见。</p>
<p><strong>volatile似乎是有时候可以代替简单的锁，似乎加了volatile关键字就省掉了锁。但又说volatile不能保证原子性（java程序员很熟悉这句话：volatile仅仅用来保证该变量对所有线程的可见性，但不保证原子性）</strong>。这不是互相矛盾吗？</p>
<h4 id="不要将volatile用在getAndOperate场合，仅仅set或者get的场景是适合volatile的"><a href="#不要将volatile用在getAndOperate场合，仅仅set或者get的场景是适合volatile的" class="headerlink" title="不要将volatile用在getAndOperate场合，仅仅set或者get的场景是适合volatile的"></a>不要将volatile用在getAndOperate场合，仅仅set或者get的场景是适合volatile的</h4><p><strong>不要将volatile用在getAndOperate场合（这种场合不原子，需要再加锁），仅仅set或者get的场景是适合volatile的</strong>。</p>
<h4 id="volatile没有原子性举例：AtomicInteger自增"><a href="#volatile没有原子性举例：AtomicInteger自增" class="headerlink" title="volatile没有原子性举例：AtomicInteger自增"></a>volatile没有原子性举例：AtomicInteger自增</h4><p>例如你让一个volatile的integer自增（i++），其实要分成3步：1）读取volatile变量值到local； 2）增加变量的值；3）把local的值写回，让其它的线程可见。这3步的jvm指令为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mov    0xc(%r10),%r8d ; Load</span><br><span class="line">inc    %r8d           ; Increment</span><br><span class="line">mov    %r8d,0xc(%r10) ; Store</span><br><span class="line">lock addl <span class="variable">$0x0</span>,(%rsp) ; StoreLoad Barrier</span><br></pre></td></tr></table></figure>

<p>注意最后一步是内存屏障。</p>
<h4 id="什么是内存屏障（Memory-Barrier）？"><a href="#什么是内存屏障（Memory-Barrier）？" class="headerlink" title="什么是内存屏障（Memory Barrier）？"></a>什么是内存屏障（Memory Barrier）？</h4><p>内存屏障（<a href="http://en.wikipedia.org/wiki/Memory_barrier" target="_blank" rel="noopener">memory barrier</a>）是一个CPU指令。基本上，它是这样一条指令： a) 确保一些特定操作执行的顺序； b) 影响一些数据的可见性(可能是某些指令执行后的结果)。编译器和CPU可以在保证输出结果一样的情况下对指令重排序，使性能得到优化。插入一个内存屏障，相当于告诉CPU和编译器先于这个命令的必须先执行，后于这个命令的必须后执行。内存屏障另一个作用是强制更新一次不同CPU的缓存。例如，一个写屏障会把这个屏障前写入的数据刷新到缓存，这样任何试图读取该数据的线程将得到最新值，而不用考虑到底是被哪个cpu核心或者哪颗CPU执行的。</p>
<p>内存屏障（<a href="http://en.wikipedia.org/wiki/Memory_barrier" target="_blank" rel="noopener">memory barrier</a>）和volatile什么关系？上面的虚拟机指令里面有提到，如果你的字段是volatile，Java内存模型将在写操作后插入一个写屏障指令，在读操作前插入一个读屏障指令。这意味着如果你对一个volatile字段进行写操作，你必须知道：1、一旦你完成写入，任何访问这个字段的线程将会得到最新的值。2、在你写入前，会保证所有之前发生的事已经发生，并且任何更新过的数据值也是可见的，因为内存屏障会把之前的写入值都刷新到缓存。</p>
<h4 id="volatile为什么没有原子性"><a href="#volatile为什么没有原子性" class="headerlink" title="volatile为什么没有原子性?"></a>volatile为什么没有原子性?</h4><p>明白了内存屏障（<a href="http://en.wikipedia.org/wiki/Memory_barrier" target="_blank" rel="noopener">memory barrier</a>）这个CPU指令，回到前面的JVM指令：从Load到store到内存屏障，一共4步，其中最后一步jvm让这个最新的变量的值在所有线程可见，也就是最后一步让所有的CPU内核都获得了最新的值，但<strong>中间的几步（从Load到Store）</strong>是不安全的，中间如果其他的CPU修改了值将会丢失。下面的测试代码可以实际测试voaltile的自增没有原子性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">long</span> _longVal = <span class="number">0</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LoopVolatile</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">long</span> val = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (val &lt; <span class="number">10000000L</span>) &#123;</span><br><span class="line">                _longVal++;</span><br><span class="line">                val++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LoopVolatile2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">long</span> val = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (val &lt; <span class="number">10000000L</span>) &#123;</span><br><span class="line">                _longVal++;</span><br><span class="line">                val++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">private</span>  <span class="keyword">void</span> <span class="title">testVolatile</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> LoopVolatile());</span><br><span class="line">        t1.start();</span><br><span class="line">         </span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> LoopVolatile2());</span><br><span class="line">        t2.start();</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">while</span> (t1.isAlive() || t2.isAlive()) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        System.out.println(<span class="string">"final val is: "</span> + _longVal);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">Output:-------------</span><br><span class="line"><span class="keyword">final</span> val is: <span class="number">11223828</span></span><br><span class="line"><span class="keyword">final</span> val is: <span class="number">17567127</span></span><br><span class="line"><span class="keyword">final</span> val is: <span class="number">12912109</span></span><br></pre></td></tr></table></figure>

<h4 id="volatile没有原子性举例：singleton单例模式实现"><a href="#volatile没有原子性举例：singleton单例模式实现" class="headerlink" title="volatile没有原子性举例：singleton单例模式实现"></a>volatile没有原子性举例：singleton单例模式实现</h4><p>这是一段线程不安全的singleton（单例模式）实现，尽管使用了volatile：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">wrongsingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> wrongsingleton _instance = <span class="keyword">null</span>; </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">wrongsingleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> wrongsingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (_instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            _instance = <span class="keyword">new</span> wrongsingleton();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> _instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的测试代码可以测试出是线程不安全的：</p>
<p>原因自然和上面的例子是一样的。因为<strong>volatile保证变量对线程的可见性，但不保证原子性</strong>。</p>
<p>附：正确线程安全的单例模式写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SafeLazyInitialization</span> </span>&#123; </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> Resource resource; </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> Resource <span class="title">getInstance</span><span class="params">()</span> </span>&#123; </span><br><span class="line">      <span class="keyword">if</span> (resource == <span class="keyword">null</span>) </span><br><span class="line">          resource = <span class="keyword">new</span> Resource(); </span><br><span class="line">      <span class="keyword">return</span> resource; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外一种写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EagerInitialization</span> </span>&#123; </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Resource resource = <span class="keyword">new</span> Resource(); </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Resource <span class="title">getResource</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> resource; &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>延迟初始化的写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceFactory</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceHolder</span> </span>&#123; </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Resource resource = <span class="keyword">new</span> Resource(); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Resource <span class="title">getResource</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> ResourceHolder.resource ; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二次检查锁定/Double Checked Locking的写法（反模式）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> SingletonDemo instance = <span class="keyword">null</span>;<span class="comment">//注意需要volatile</span></span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonDemo</span><span class="params">()</span> </span>&#123;   &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123; <span class="comment">//二次检查，比直接用独占锁效率高</span></span><br><span class="line">               <span class="keyword">synchronized</span> (SingletonDemo <span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                               instance = <span class="keyword">new</span> SingletonDemo (); </span><br><span class="line">                    &#125;</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="为什么AtomicXXX具有原子性和可见性？"><a href="#为什么AtomicXXX具有原子性和可见性？" class="headerlink" title="为什么AtomicXXX具有原子性和可见性？"></a>为什么AtomicXXX具有原子性和可见性？</h4><p>就拿AtomicLong来说，它既解决了上述的volatile的原子性没有保证的问题，又具有可见性。它是如何做到的？当然就是上文《<a href="http://www.cnblogs.com/Mainz/p/3546347.html" target="_blank" rel="noopener">非阻塞同步算法与CAS(Compare and Swap)无锁算法</a>》提到的CAS（比较并交换）指令。 其实AtomicLong的源码里也用到了volatile，但只是用来读取或写入，见源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicLong</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> value;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new AtomicLong with the given initial value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initialValue the initial value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AtomicLong</span><span class="params">(<span class="keyword">long</span> initialValue)</span> </span>&#123;</span><br><span class="line">        value = initialValue;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new AtomicLong with initial value &#123;<span class="doctag">@code</span> 0&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AtomicLong</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>其CAS源码核心代码为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare_and_swap</span> <span class="params">(<span class="keyword">int</span>* reg, <span class="keyword">int</span> oldval, <span class="keyword">int</span> newval)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ATOMIC();</span><br><span class="line">  <span class="keyword">int</span> old_reg_val = *reg;</span><br><span class="line">  <span class="keyword">if</span> (old_reg_val == oldval) </span><br><span class="line">     *reg = newval;</span><br><span class="line">  END_ATOMIC();</span><br><span class="line">  <span class="keyword">return</span> old_reg_val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虚拟机指令为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mov    0xc(%r11),%eax       ; Load</span><br><span class="line">mov    %eax,%r8d            </span><br><span class="line">inc    %r8d                 ; Increment</span><br><span class="line">lock cmpxchg %r8d,0xc(%r11) ; Compare and exchange</span><br></pre></td></tr></table></figure>

<p>因为CAS是基于乐观锁的，也就是说当写入的时候，如果寄存器旧值已经不等于现值，说明有其他CPU在修改，那就继续尝试。所以这就保证了操作的原子性。</p>
<p><img src="/2020/02/01/volatile%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7/191824497484728.png" alt="ConcurrencyCAS"></p>
<p>原文转载自：<a href="https://www.cnblogs.com/lfalex0831/p/9516777.html" target="_blank" rel="noopener">https://www.cnblogs.com/lfalex0831/p/9516777.html</a></p>
<hr>
<h1 id="为什么volatile-不是原子性的"><a href="#为什么volatile-不是原子性的" class="headerlink" title="为什么volatile++不是原子性的"></a>为什么volatile++不是原子性的</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在讨论原子性操作时，我们经常会听到一个说法：任意单个volatile变量的读写具有原子性，但是volatile++这种操作除外。</p>
<p>所以问题就是：为什么volatile++不是原子性的？</p>
<h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><p>因为它实际上是三个操作组成的一个符合操作。</p>
<p>首先获取volatile变量的值<br>将该变量的值加1<br>将该volatile变量的值写会到对应的主存地址<br>一个很简单的例子：</p>
<p>如果两个线程在volatile读阶段都拿到的是a=1，那么后续在线程对应的CPU核心上进行自增当然都得到的是a=2，最后两个写操作不管怎么保证原子性，结果最终都是a=2。每个操作本身都没啥问题，但是合在一起，从整体上看就是一个线程不安全的操作：发生了两次自增操作，然而最终结果却不是3。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>结合内存屏障这个概念对volatile的读写操作深入理解的话：</p>
<h3 id="第一步：读"><a href="#第一步：读" class="headerlink" title="第一步：读"></a>第一步：读</h3><p>在第一步操作的指令后，会增加两个内存屏障：</p>
<p>在Volatile读操作后插入LoadLoad屏障，防止前面的Volatile读与后面的普通读重排序<br>在Volatile读操作后插入LoadStore屏障，防止前面的Volatile读与后面的普通写重排序<br>因此第一个指令和它后续的普通读写操作会被保证没有重排序来捣乱。通常是去内存中去读。</p>
<p>那么问题又来了，为什么通常去内存中读？</p>
<p>其实这个问题要说细的话可以很细，大概就两个关键点吧：</p>
<p>volatile的写操作的缓存失效机制<br>最后一个对volatile变量执行写操作的CPU，由于在它对应的缓存中保有最新的值，因此可以不用再去主存里面获取<br>具体看下面第三步的分析。</p>
<h3 id="第二步：自增"><a href="#第二步：自增" class="headerlink" title="第二步：自增"></a>第二步：自增</h3><p>这个步骤没什么特别的，就是在CPU自身的高速缓存(寄存器，L1-L3 Cache)中完成。不涉及到缓存和内存的交互。</p>
<h3 id="第三步：写"><a href="#第三步：写" class="headerlink" title="第三步：写"></a>第三步：写</h3><p>volatile写算是一个重点。</p>
<p>根据JMM对于volatile变量类型的语义规范：volatile在编译之后，会在变量写操作时添加LOCK前缀指令。这个LOCK前缀指令在多核处理器的环境中，有这样的作用：</p>
<p>通知CPU将当前处理器缓存行的数据写回到系统主存中<br>该写回操作将使其他CPU缓存了该内存地址的数据无效<br>另外，内存屏障在volatile的写操作中起到了很大的作用，来保证上面两点能够实现：</p>
<p>在Volatile写操作前插入StoreStore屏障，防止前面其他写与本次Volatile写重排序<br>在Volatile写操作后插入StoreLoad屏障，防止本次的Volatile写与后面的读操作重排序</p>
<h2 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h2><p>那么为了解决volatile++这类复合操作的原子性，有什么方案呢？其实方案也比较多的，这里提供两种典型的：</p>
<p>使用synchronized关键字<br>使用AtomicInteger/AtomicLong原子类型</p>
<h2 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h2><p>synchronized是比较原始的同步手段。它本质上是一个独占的，可重入的锁。当一个线程尝试获取它的时候，可能会被阻塞住，所以高并发的场景下性能存在一些问题。</p>
<p>在某些场景下，使用synchronized关键字和volatile是等价的：</p>
<p>写入变量值时候不依赖变量的当前值，或者能够保证只有一个线程修改变量值。<br>写入的变量值不依赖其他变量的参与。<br>读取变量值时候不能因为其他原因进行加锁。<br>加锁可以同时保证可见性和原子性，而volatile只保证变量值的可见性。</p>
<h2 id="AtomicInteger-AtomicLong"><a href="#AtomicInteger-AtomicLong" class="headerlink" title="AtomicInteger/AtomicLong"></a>AtomicInteger/AtomicLong</h2><p>这类原子类型比锁更加轻巧，比如AtomicInteger/AtomicLong分别就代表了整型变量和长整型变量。</p>
<p>在它们的实现中，实际上分别使用的volatile int/volatile long保存了真正的值。因此，也是通过volatile来保证对于单个变量的读写原子性的。</p>
<p>在此基础之上，它们提供了原子性的自增自减操作。比如incrementAndGet方法，这类方法相对于synchronized的好处是：它们不会导致线程的挂起和重新调度，因为在其内部使用的是CAS非阻塞算法。</p>
<h2 id="CAS是什么"><a href="#CAS是什么" class="headerlink" title="CAS是什么"></a>CAS是什么</h2><p>所谓的CAS全程为CompareAndSet。直译过来就是比较并设置。这个操作需要接受三个参数：</p>
<p>内存位置<br>旧的预期值<br>新值<br>这个操作的做法就是看指定内存位置的值符不符合旧的预期值，如果符合的话就将它替换成新值。它对应的是处理器提供的一个原子性指令 - CMPXCHG。</p>
<p>比如AtomicLong的自增操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">long</span> current = get(); <span class="comment">// Step 1</span></span><br><span class="line">        <span class="keyword">long</span> next = current + <span class="number">1</span>; <span class="comment">// Step 2</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSet(current, next)) <span class="comment">// Step 3</span></span><br><span class="line">            <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">long</span> expect, <span class="keyword">long</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapLong(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>我们考虑两个线程T1和T2，同时执行到了上述Step 1处，都拿到了current值为1。然后通过Step 2之后，current在两个线程中都被设置为2。</p>
<p>紧接着，来到Step 3。假设线程T1先执行，此时符合CompareAndSet的设置规则，因此内存位置对应的值被设置成2，线程T1设置成功。当线程T2执行的时候，由于它预期current为1，但是实际上已经变成了2，所以CompareAndSet执行不成功，进入到下一轮的for循环中，此时拿到最新的current值为2，如果没有其它线程感染的话，再次执行CompareAndSet的时候就能够通过，current值被更新为3。</p>
<p>所以不难发现，CAS的工作主要依赖于两点：</p>
<p>无限循环，需要消耗部分CPU性能<br>CPU原子指令CompareAndSet<br>虽然它需要耗费一定的CPU Cycle，但是相比锁而言还是有其优势，比如它能够避免线程阻塞引起的上下文切换和调度。这两类操作的量级明显是不一样的，CAS更轻量一些。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们说对于volatile变量的读/写操作是原子性的。因为从内存屏障的角度来看，对volatile变量的单纯读写操作确实没有任何疑问。</p>
<p>由于其中掺杂了一个自增的CPU内部操作，就造成这个复合操作不再保有原子性。</p>
<p>然后，讨论了如何保证volatile++这类操作的原子性，比如使用synchronized或者AtomicInteger/AtomicLong原子类。</p>
<p>原文转载自：<a href="https://blog.csdn.net/dm_vincent/article/details/79604716" target="_blank" rel="noopener">https://blog.csdn.net/dm_vincent/article/details/79604716</a></p>
<hr>
<h1 id="既然synchronized是”万能”的，为什么还需要volatile呢"><a href="#既然synchronized是”万能”的，为什么还需要volatile呢" class="headerlink" title="既然synchronized是”万能”的，为什么还需要volatile呢"></a>既然synchronized是”万能”的，为什么还需要volatile呢</h1><p>在我的博客和公众号中，发表过很多篇关于并发编程的文章，之前的文章中我们介绍过了两个在Java并发编程中比较重要的两个关键字：synchronized和volatile</p>
<p>我们简单回顾一下相关内容：</p>
<p>1、Java语言为了解决并发编程中存在的原子性、可见性和有序性问题，提供了一系列和并发处理相关的关键字，比如synchronized、volatile、final、concurren包等。(<a href="http://www.hollischuang.com/archives/2550" target="_blank" rel="noopener">再有人问你Java内存模型是什么，就把这篇文章发给他</a>)</p>
<p>2、synchronized通过加锁的方式，使得其在需要原子性、可见性和有序性这三种特性的时候都可以作为其中一种解决方案，看起来是“万能”的。的确，大部分并发控制操作都能使用synchronized来完成。<a href="https://www.hollischuang.com/archives/2637" target="_blank" rel="noopener">再有人问你synchronized是什么，就把这篇文章发给他。</a></p>
<p>3、volatile通过在volatile变量的操作前后插入内存屏障的方式，保证了变量在并发场景下的可见性和有序性。<a href="https://www.hollischuang.com/archives/2673" target="_blank" rel="noopener">再有人问你volatile是什么，把这篇文章也发给他</a></p>
<p>4、volatile关键字是无法保证原子性的，而synchronized通过monitorenter和monitorexit两个指令，可以保证被synchronized修饰的代码在同一时间只能被一个线程访问，即可保证不会出现CPU时间片在多个线程间切换，即可保证原子性。<a href="http://www.hollischuang.com/archives/2618" target="_blank" rel="noopener">Java的并发编程中的多线程问题到底是怎么回事儿？</a></p>
<p>那么，我们知道，synchronized和volatile两个关键字是Java并发编程中经常用到的两个关键字，而且，通过前面的回顾，我们知道synchronized可以保证并发编程中不会出现原子性、可见性和有序性问题，而volatile只能保证可见性和有序性，那么，<strong>既生synchronized、何生volatile？</strong></p>
<h3 id="synchronized的问题"><a href="#synchronized的问题" class="headerlink" title="synchronized的问题"></a>synchronized的问题</h3><p>我们都知道synchronized其实是一种加锁机制，那么既然是锁，天然就具备以下几个缺点：</p>
<p>1、有性能损耗</p>
<p>虽然在JDK 1.6中对synchronized做了很多优化，如如适应性自旋、锁消除、锁粗化、轻量级锁和偏向锁等（<a href="https://www.hollischuang.com/archives/2344" target="_blank" rel="noopener">深入理解多线程（五）—— Java虚拟机的锁优化技术</a>），但是他毕竟还是一种锁。</p>
<p>以上这几种优化，都是尽量想办法避免对Monitor（<a href="http://www.hollischuang.com/archives/2030" target="_blank" rel="noopener">深入理解多线程（四）—— Moniter的实现原理</a>）进行加锁，但是，并不是所有情况都可以优化的，况且就算是经过优化，优化的过程也是有一定的耗时的。</p>
<p>所以，无论是使用同步方法还是同步代码块，在同步操作之前还是要进行加锁，同步操作之后需要进行解锁，这个加锁、解锁的过程是要有性能损耗的。</p>
<p>关于二者的性能对比，由于虚拟机对锁实行的许多消除和优化，使得我们很难量化这两者之间的性能差距，但是我们可以确定的一个基本原则是：volatile变量的读操作的性能小号普通变量几乎无差别，但是写操作由于需要插入内存屏障所以会慢一些，即便如此，volatile在大多数场景下也比锁的开销要低。</p>
<p>2、产生阻塞</p>
<p>我们在<a href="http://www.hollischuang.com/archives/1883" target="_blank" rel="noopener">深入理解多线程（一）——Synchronized的实现原理</a>中介绍过关于synchronize的实现原理，无论是同步方法还是同步代码块，无论是ACC_SYNCHRONIZED还是monitorenter、monitorexit都是基于Monitor实现的。</p>
<p>基于Monitor对象，当多个线程同时访问一段同步代码时，首先会进入Entry Set，当有一个线程获取到对象的锁之后，才能进行The Owner区域，其他线程还会继续在Entry Set等待。并且当某个线程调用了wait方法后，会释放锁并进入Wait Set等待。</p>
<p><img src="/2020/02/01/volatile%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7/15660298698995.jpg" alt="img">￼</p>
<p>所以，synchronize实现的锁本质上是一种阻塞锁，也就是说多个线程要排队访问同一个共享对象。</p>
<p>而volatile是Java虚拟机提供的一种轻量级同步机制，他是基于内存屏障实现的。说到底，他并不是锁，所以他不会有synchronized带来的阻塞和性能损耗的问题。</p>
<h3 id="volatile的附加功能"><a href="#volatile的附加功能" class="headerlink" title="volatile的附加功能"></a>volatile的附加功能</h3><p>除了前面我们提到的volatile比synchronized性能好以外，volatile其实还有一个很好的附加功能，那就是禁止指令重排。</p>
<p>我们先来举一个例子，看一下如果只使用synchronized而不使用volatile会发生什么问题，就拿我们比较熟悉的单例模式来看。</p>
<p>我们通过双重校验锁的方式实现一个单例，这里不使用volatile关键字：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1   public class Singleton &#123;  </span><br><span class="line">2      private static Singleton singleton;  </span><br><span class="line">3       private Singleton ()&#123;&#125;  </span><br><span class="line">4       public static Singleton getSingleton() &#123;  </span><br><span class="line">5       if (singleton &#x3D;&#x3D; null) &#123;  </span><br><span class="line">6           synchronized (Singleton.class) &#123;  </span><br><span class="line">7               if (singleton &#x3D;&#x3D; null) &#123;  </span><br><span class="line">8                   singleton &#x3D; new Singleton();  </span><br><span class="line">9               &#125;  </span><br><span class="line">10           &#125;  </span><br><span class="line">11       &#125;  </span><br><span class="line">12       return singleton;  </span><br><span class="line">13       &#125;  </span><br><span class="line">14   &#125;</span><br></pre></td></tr></table></figure>

<p>以上代码，我们通过使用synchronized对Singleton.class进行加锁，可以保证同一时间只有一个线程可以执行到同步代码块中的内容，也就是说singleton = new Singleton()这个操作只会执行一次，这就是实现了一个单例。</p>
<p>但是，当我们在代码中使用上述单例对象的时候有可能发生空指针异常。这是一个比较诡异的情况。</p>
<p>我们假设Thread1 和 Thread2两个线程同时请求Singleton.getSingleton方法的时候：</p>
<p><img src="/2020/02/01/volatile%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7/15660330700367.jpg" alt="img">￼</p>
<p>Step1 ,Thread1执行到第8行，开始进行对象的初始化。 Step2 ,Thread2执行到第5行，判断singleton == null。 Step3 ,Thread2经过判断发现singleton ！= null，所以执行第12行，返回singleton。 Step4 ,Thread2拿到singleton对象之后，开始执行后续的操作，比如调用singleton.call()。</p>
<p>以上过程，看上去并没有什么问题，但是，其实，在Step4，Thread2在调用singleton.call()的时候，是有可能抛出空指针异常的。</p>
<p>之所有会有NPE抛出，是因为在Step3，Thread2拿到的singleton对象并不是一个完整的对象。</p>
<p>我们这里来分析一下，singleton = new Singleton();这行代码到底做了什么事情，大致过程如下：</p>
<p>1、虚拟机遇到new指令，到常量池定位到这个类的符号引用。 2、检查符号引用代表的类是否被加载、解析、初始化过。 3、虚拟机为对象分配内存。 4、虚拟机将分配到的内存空间都初始化为零值。 5、虚拟机对对象进行必要的设置。 6、执行方法，成员变量进行初始化。 7、将对象的引用指向这个内存区域。</p>
<p>我们把这个过程简化一下，简化成3个步骤：</p>
<p>a、JVM为对象分配一块内存M b、在内存M上为对象进行初始化 c、将内存M的地址复制给singleton变量</p>
<p><img src="/2020/02/01/volatile%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7/15660328514676.jpg" alt="img">￼</p>
<p>因为将内存的地址赋值给singleton变量是最后一步，所以Thread1在这一步骤执行之前，Thread2在对singleton==null进行判断一直都是true的，那么他会一直阻塞，直到Thread1将这一步骤执行完。</p>
<p>但是，以上过程并不是一个原子操作，并且编译器可能会进行重排序，如果以上步骤被重排成：</p>
<p>a、JVM为对象分配一块内存M c、将内存的地址复制给singleton变量 b、在内存M上为对象进行初始化</p>
<p><img src="/2020/02/01/volatile%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7/15660329140984.jpg" alt="img">￼</p>
<p>这样的话，Thread1会先执行内存分配，在执行变量赋值，最后执行对象的初始化，那么，也就是说，在Thread1还没有为对象进行初始化的时候，Thread2进来判断singleton==null就可能提前得到一个false，则会返回一个不完整的sigleton对象，因为他还未完成初始化操作。</p>
<p>这种情况一旦发生，我们拿到了一个不完整的singleton对象，当尝试使用这个对象的时候就极有可能发生NPE异常。</p>
<p>那么，怎么解决这个问题呢？因为指令重排导致了这个问题，那就避免指令重排就行了。</p>
<p>所以，volatile就派上用场了，因为volatile可以避免指令重排。只要将代码改成以下代码，就可以解决这个问题：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1   public class Singleton &#123;  </span><br><span class="line">2      private volatile static Singleton singleton;  </span><br><span class="line">3       private Singleton ()&#123;&#125;  </span><br><span class="line">4       public static Singleton getSingleton() &#123;  </span><br><span class="line">5       if (singleton &#x3D;&#x3D; null) &#123;  </span><br><span class="line">6           synchronized (Singleton.class) &#123;  </span><br><span class="line">7               if (singleton &#x3D;&#x3D; null) &#123;  </span><br><span class="line">8                   singleton &#x3D; new Singleton();  </span><br><span class="line">9               &#125;  </span><br><span class="line">10           &#125;  </span><br><span class="line">11       &#125;  </span><br><span class="line">12       return singleton;  </span><br><span class="line">13       &#125;  </span><br><span class="line">14   &#125;</span><br></pre></td></tr></table></figure>

<p>对singleton使用volatile约束，保证他的初始化过程不会被指令重排。</p>
<h3 id="synchronized的有序性保证呢？"><a href="#synchronized的有序性保证呢？" class="headerlink" title="synchronized的有序性保证呢？"></a>synchronized的有序性保证呢？</h3><p>看到这里可能有朋友会问了，说到底上面问题还是个有序性的问题，不是说synchronized是可以保证有序性的么，这里为什么就不行了呢？</p>
<p>首先，可以明确的一点是：<strong>synchronized是无法禁止指令重排和处理器优化的</strong>。那么他是如何保证的有序性呢？</p>
<p>这就要再把有序性的概念扩展一下了。Java程序中天然的有序性可以总结为一句话：如果在本线程内观察，所有操作都是天然有序的。如果在一个线程中观察另一个线程，所有操作都是无序的。</p>
<p>以上这句话也是《深入理解Java虚拟机》中的原句，但是怎么理解呢？周志明并没有详细的解释。这里我简单扩展一下，这其实和as-if-serial语义有关。</p>
<p>as-if-serial语义的意思指：不管怎么重排序，单线程程序的执行结果都不能被改变。编译器和处理器无论如何优化，都必须遵守as-if-serial语义。</p>
<p>这里不对as-if-serial语义详细展开了，简单说就是，as-if-serial语义保证了单线程中，不管指令怎么重排，最终的执行结果是不能被改变的。</p>
<p>那么，我们回到刚刚那个双重校验锁的例子，站在单线程的角度，也就是只看Thread1的话，因为编译器会遵守as-if-serial语义，所以这种优化不会有任何问题，对于这个线程的执行结果也不会有任何影响。</p>
<p>但是，Thread1内部的指令重排却对Thread2产生了影响。</p>
<p>那么，我们可以说，synchronized保证的有序性是多个线程之间的有序性，即被加锁的内容要按照顺序被多个线程执行。但是其内部的同步代码还是会发生重排序，只不过由于编译器和处理器都遵循as-if-serial语义，所以我们可以认为这些重排序在单线程内部可忽略。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>本文从两方面论述了volatile的重要性以及不可替代性：</p>
<p>一方面是因为synchronized是一种锁机制，存在阻塞问题和性能问题，而volatile并不是锁，所以不存在阻塞和性能问题。</p>
<p>另外一方面，因为volatile借助了内存屏障来帮助其解决可见性和有序性问题，而内存屏障的使用还为其带来了一个禁止指令重排的附件功能，所以在有些场景中是可以避免发生指令重排的问题的。</p>
<p>原文转载自：<a href="https://www.cnblogs.com/hollischuang/p/11386988.html" target="_blank" rel="noopener">https://www.cnblogs.com/hollischuang/p/11386988.html</a></p>
]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>volatile</tag>
        <tag>原子性</tag>
      </tags>
  </entry>
  <entry>
    <title>var-lib-docker-volumes-在哪里</title>
    <url>/2020/02/01/var-lib-docker-volumes-%E5%9C%A8%E5%93%AA%E9%87%8C/</url>
    <content><![CDATA[<p>使用过docker的玩家应该知道，docker 容器启动的时候是可以指定宿主目录到容器内目录的映射的，使用-v参数和-mount 都可以，两者的区别是如果使用-v参数，你指定的目录还不存在，那么docker会帮你创建，而如果使用-mount 你指定的目录不再，那么容器会启动失败。但是好像现在版本的docker也是会帮你创建的。</p>
<h3 id="使用docker-启动一个nexus3-仓库"><a href="#使用docker-启动一个nexus3-仓库" class="headerlink" title="使用docker 启动一个nexus3 仓库"></a>使用docker 启动一个nexus3 仓库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># os macos</span></span><br><span class="line"></span><br><span class="line">docker run -d --name nexus3 --restart=always \</span><br><span class="line">    -p 8081:8081 \</span><br><span class="line">    --mount src=nexus-data,target=/nexus-data \</span><br><span class="line">    sonatype/nexus3</span><br></pre></td></tr></table></figure>

<p>可以看到这里的src 指定的目录是一个相对路径的，–mount参数说明的是我们在本地的一个相对目录nexus-data挂载到容器的/nexus-data 目录。因为是nexus仓库，所以我就想是不是可以去找到这个nexus-data 相对路径，这样在nexus上传的一些软件包是可以看到的，这样我心里也有些底。但是我使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find / -name nexus-data</span><br><span class="line"><span class="comment"># 找了一圈，并没有</span></span><br></pre></td></tr></table></figure>

<p>如果在我的整个磁盘都找不到，那就说明起码这个目录不是一个实际的目录。</p>
<h3 id="docker-inspect-xxxx"><a href="#docker-inspect-xxxx" class="headerlink" title="docker inspect xxxx"></a>docker inspect xxxx</h3><p>使用docker inspect 命令可以查看容器的元数据信息，也就是说，你可以看到这个容器相关的信息，包括映射的数据卷，网络，端口信息等。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker inspect 8a</span><br><span class="line"></span><br><span class="line">docker inspect 8a</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"Id"</span>: <span class="string">"8a4922b62bd5fae5912c8cda3207b40a6885addcb39924593b771465b427b20a"</span>,</span><br><span class="line">        <span class="string">"Created"</span>: <span class="string">"2020-02-01T10:49:24.1509652Z"</span>,</span><br><span class="line">        <span class="string">"Path"</span>: <span class="string">"sh"</span>,</span><br><span class="line">        <span class="string">"Args"</span>: [</span><br><span class="line">            <span class="string">"-c"</span>,</span><br><span class="line">            <span class="string">"<span class="variable">$&#123;SONATYPE_DIR&#125;</span>/start-nexus-repository-manager.sh"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="string">"State"</span>: &#123;</span><br><span class="line">            <span class="string">"Status"</span>: <span class="string">"running"</span>,</span><br><span class="line">            <span class="string">"Running"</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="string">"Paused"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"Restarting"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"OOMKilled"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"Dead"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"Pid"</span>: 2980,</span><br><span class="line">            <span class="string">"ExitCode"</span>: 0,</span><br><span class="line">            <span class="string">"Error"</span>: <span class="string">""</span>,</span><br><span class="line">            <span class="string">"StartedAt"</span>: <span class="string">"2020-02-01T10:49:24.5467565Z"</span>,</span><br><span class="line">            <span class="string">"FinishedAt"</span>: <span class="string">"0001-01-01T00:00:00Z"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"Image"</span>: <span class="string">"sha256:87d9a097d22c541e8be83a5edd0b8ed528850afeb81b1630a424e1c9814d3309"</span>,</span><br><span class="line">        <span class="string">"ResolvConfPath"</span>: <span class="string">"/var/lib/docker/containers/8a4922b62bd5fae5912c8cda3207b40a6885addcb39924593b771465b427b20a/resolv.conf"</span>,</span><br><span class="line">        <span class="string">"HostnamePath"</span>: <span class="string">"/var/lib/docker/containers/8a4922b62bd5fae5912c8cda3207b40a6885addcb39924593b771465b427b20a/hostname"</span>,</span><br><span class="line">        <span class="string">"HostsPath"</span>: <span class="string">"/var/lib/docker/containers/8a4922b62bd5fae5912c8cda3207b40a6885addcb39924593b771465b427b20a/hosts"</span>,</span><br><span class="line">        <span class="string">"LogPath"</span>: <span class="string">"/var/lib/docker/containers/8a4922b62bd5fae5912c8cda3207b40a6885addcb39924593b771465b427b20a/8a4922b62bd5fae5912c8cda3207b40a6885addcb39924593b771465b427b20a-json.log"</span>,</span><br><span class="line">        <span class="string">"Name"</span>: <span class="string">"/nexus3"</span>,</span><br><span class="line">        <span class="string">"RestartCount"</span>: 0,</span><br><span class="line">        <span class="string">"Driver"</span>: <span class="string">"overlay2"</span>,</span><br><span class="line">        <span class="string">"Platform"</span>: <span class="string">"linux"</span>,</span><br><span class="line">        <span class="string">"MountLabel"</span>: <span class="string">""</span>,</span><br><span class="line">        <span class="string">"ProcessLabel"</span>: <span class="string">""</span>,</span><br><span class="line">        <span class="string">"AppArmorProfile"</span>: <span class="string">""</span>,</span><br><span class="line">        <span class="string">"ExecIDs"</span>: null,</span><br><span class="line">        <span class="string">"HostConfig"</span>: &#123;</span><br><span class="line">            <span class="string">"Binds"</span>: null,</span><br><span class="line">            <span class="string">"ContainerIDFile"</span>: <span class="string">""</span>,</span><br><span class="line">            <span class="string">"LogConfig"</span>: &#123;</span><br><span class="line">                <span class="string">"Type"</span>: <span class="string">"json-file"</span>,</span><br><span class="line">                <span class="string">"Config"</span>: &#123;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">"NetworkMode"</span>: <span class="string">"default"</span>,</span><br><span class="line">            <span class="string">"PortBindings"</span>: &#123;</span><br><span class="line">                <span class="string">"8081/tcp"</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="string">"HostIp"</span>: <span class="string">""</span>,</span><br><span class="line">                        <span class="string">"HostPort"</span>: <span class="string">"8081"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">"RestartPolicy"</span>: &#123;</span><br><span class="line">                <span class="string">"Name"</span>: <span class="string">"always"</span>,</span><br><span class="line">                <span class="string">"MaximumRetryCount"</span>: 0</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">"AutoRemove"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"VolumeDriver"</span>: <span class="string">""</span>,</span><br><span class="line">            <span class="string">"VolumesFrom"</span>: null,</span><br><span class="line">            <span class="string">"CapAdd"</span>: null,</span><br><span class="line">            <span class="string">"CapDrop"</span>: null,</span><br><span class="line">            <span class="string">"Capabilities"</span>: null,</span><br><span class="line">            <span class="string">"Dns"</span>: [],</span><br><span class="line">            <span class="string">"DnsOptions"</span>: [],</span><br><span class="line">            <span class="string">"DnsSearch"</span>: [],</span><br><span class="line">            <span class="string">"ExtraHosts"</span>: null,</span><br><span class="line">            <span class="string">"GroupAdd"</span>: null,</span><br><span class="line">            <span class="string">"IpcMode"</span>: <span class="string">"private"</span>,</span><br><span class="line">            <span class="string">"Cgroup"</span>: <span class="string">""</span>,</span><br><span class="line">            <span class="string">"Links"</span>: null,</span><br><span class="line">            <span class="string">"OomScoreAdj"</span>: 0,</span><br><span class="line">            <span class="string">"PidMode"</span>: <span class="string">""</span>,</span><br><span class="line">            <span class="string">"Privileged"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"PublishAllPorts"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"ReadonlyRootfs"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"SecurityOpt"</span>: null,</span><br><span class="line">            <span class="string">"UTSMode"</span>: <span class="string">""</span>,</span><br><span class="line">            <span class="string">"UsernsMode"</span>: <span class="string">""</span>,</span><br><span class="line">            <span class="string">"ShmSize"</span>: 67108864,</span><br><span class="line">            <span class="string">"Runtime"</span>: <span class="string">"runc"</span>,</span><br><span class="line">            <span class="string">"ConsoleSize"</span>: [</span><br><span class="line">                0,</span><br><span class="line">                0</span><br><span class="line">            ],</span><br><span class="line">            <span class="string">"Isolation"</span>: <span class="string">""</span>,</span><br><span class="line">            <span class="string">"CpuShares"</span>: 0,</span><br><span class="line">            <span class="string">"Memory"</span>: 0,</span><br><span class="line">            <span class="string">"NanoCpus"</span>: 0,</span><br><span class="line">            <span class="string">"CgroupParent"</span>: <span class="string">""</span>,</span><br><span class="line">            <span class="string">"BlkioWeight"</span>: 0,</span><br><span class="line">            <span class="string">"BlkioWeightDevice"</span>: [],</span><br><span class="line">            <span class="string">"BlkioDeviceReadBps"</span>: null,</span><br><span class="line">            <span class="string">"BlkioDeviceWriteBps"</span>: null,</span><br><span class="line">            <span class="string">"BlkioDeviceReadIOps"</span>: null,</span><br><span class="line">            <span class="string">"BlkioDeviceWriteIOps"</span>: null,</span><br><span class="line">            <span class="string">"CpuPeriod"</span>: 0,</span><br><span class="line">            <span class="string">"CpuQuota"</span>: 0,</span><br><span class="line">            <span class="string">"CpuRealtimePeriod"</span>: 0,</span><br><span class="line">            <span class="string">"CpuRealtimeRuntime"</span>: 0,</span><br><span class="line">            <span class="string">"CpusetCpus"</span>: <span class="string">""</span>,</span><br><span class="line">            <span class="string">"CpusetMems"</span>: <span class="string">""</span>,</span><br><span class="line">            <span class="string">"Devices"</span>: [],</span><br><span class="line">            <span class="string">"DeviceCgroupRules"</span>: null,</span><br><span class="line">            <span class="string">"DeviceRequests"</span>: null,</span><br><span class="line">            <span class="string">"KernelMemory"</span>: 0,</span><br><span class="line">            <span class="string">"KernelMemoryTCP"</span>: 0,</span><br><span class="line">            <span class="string">"MemoryReservation"</span>: 0,</span><br><span class="line">            <span class="string">"MemorySwap"</span>: 0,</span><br><span class="line">            <span class="string">"MemorySwappiness"</span>: null,</span><br><span class="line">            <span class="string">"OomKillDisable"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"PidsLimit"</span>: null,</span><br><span class="line">            <span class="string">"Ulimits"</span>: null,</span><br><span class="line">            <span class="string">"CpuCount"</span>: 0,</span><br><span class="line">            <span class="string">"CpuPercent"</span>: 0,</span><br><span class="line">            <span class="string">"IOMaximumIOps"</span>: 0,</span><br><span class="line">            <span class="string">"IOMaximumBandwidth"</span>: 0,</span><br><span class="line">            <span class="string">"Mounts"</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">"Type"</span>: <span class="string">"volume"</span>,</span><br><span class="line">                    <span class="string">"Source"</span>: <span class="string">"nexus-data"</span>,</span><br><span class="line">                    <span class="string">"Target"</span>: <span class="string">"/nexus-data"</span></span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            <span class="string">"MaskedPaths"</span>: [</span><br><span class="line">                <span class="string">"/proc/asound"</span>,</span><br><span class="line">                <span class="string">"/proc/acpi"</span>,</span><br><span class="line">                <span class="string">"/proc/kcore"</span>,</span><br><span class="line">                <span class="string">"/proc/keys"</span>,</span><br><span class="line">                <span class="string">"/proc/latency_stats"</span>,</span><br><span class="line">                <span class="string">"/proc/timer_list"</span>,</span><br><span class="line">                <span class="string">"/proc/timer_stats"</span>,</span><br><span class="line">                <span class="string">"/proc/sched_debug"</span>,</span><br><span class="line">                <span class="string">"/proc/scsi"</span>,</span><br><span class="line">                <span class="string">"/sys/firmware"</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">"ReadonlyPaths"</span>: [</span><br><span class="line">                <span class="string">"/proc/bus"</span>,</span><br><span class="line">                <span class="string">"/proc/fs"</span>,</span><br><span class="line">                <span class="string">"/proc/irq"</span>,</span><br><span class="line">                <span class="string">"/proc/sys"</span>,</span><br><span class="line">                <span class="string">"/proc/sysrq-trigger"</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"GraphDriver"</span>: &#123;</span><br><span class="line">            <span class="string">"Data"</span>: &#123;</span><br><span class="line">                <span class="string">"LowerDir"</span>: <span class="string">"/var/lib/docker/overlay2/52c36770f11b0715d003a1f5e3ea061dc9b3bc3b6eacf47918589bd57a5ccfdf-init/diff:/var/lib/docker/overlay2/e8df1a1f6dd5d3103ff9d72552c4d36d73ebbf876e911181e7ee0409e7c813da/diff:/var/lib/docker/overlay2/f93f5b6f7b7049f66293ca7fe70fdc3eaf28cdea5a3ca0221121b2bed9f06cda/diff:/var/lib/docker/overlay2/1b421d407bb2f51684c9465ea1849da256f3a7b49f95d12906730b1085ad57de/diff:/var/lib/docker/overlay2/902a4e076c3d19f70d31c8eabfb543297582db7ed3702d888d550ffcc923651f/diff"</span>,</span><br><span class="line">                <span class="string">"MergedDir"</span>: <span class="string">"/var/lib/docker/overlay2/52c36770f11b0715d003a1f5e3ea061dc9b3bc3b6eacf47918589bd57a5ccfdf/merged"</span>,</span><br><span class="line">                <span class="string">"UpperDir"</span>: <span class="string">"/var/lib/docker/overlay2/52c36770f11b0715d003a1f5e3ea061dc9b3bc3b6eacf47918589bd57a5ccfdf/diff"</span>,</span><br><span class="line">                <span class="string">"WorkDir"</span>: <span class="string">"/var/lib/docker/overlay2/52c36770f11b0715d003a1f5e3ea061dc9b3bc3b6eacf47918589bd57a5ccfdf/work"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">"Name"</span>: <span class="string">"overlay2"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"Mounts"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">"Type"</span>: <span class="string">"volume"</span>,</span><br><span class="line">                <span class="string">"Name"</span>: <span class="string">"nexus-data"</span>,</span><br><span class="line">                <span class="string">"Source"</span>: <span class="string">"/var/lib/docker/volumes/nexus-data/_data"</span>,</span><br><span class="line">                <span class="string">"Destination"</span>: <span class="string">"/nexus-data"</span>,</span><br><span class="line">                <span class="string">"Driver"</span>: <span class="string">"local"</span>,</span><br><span class="line">                <span class="string">"Mode"</span>: <span class="string">"z"</span>,</span><br><span class="line">                <span class="string">"RW"</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="string">"Propagation"</span>: <span class="string">""</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="string">"Config"</span>: &#123;</span><br><span class="line">            <span class="string">"Hostname"</span>: <span class="string">"8a4922b62bd5"</span>,</span><br><span class="line">            <span class="string">"Domainname"</span>: <span class="string">""</span>,</span><br><span class="line">            <span class="string">"User"</span>: <span class="string">"nexus"</span>,</span><br><span class="line">            <span class="string">"AttachStdin"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"AttachStdout"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"AttachStderr"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"ExposedPorts"</span>: &#123;</span><br><span class="line">                <span class="string">"8081/tcp"</span>: &#123;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">"Tty"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"OpenStdin"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"StdinOnce"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"Env"</span>: [</span><br><span class="line">                <span class="string">"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"</span>,</span><br><span class="line">                <span class="string">"container=oci"</span>,</span><br><span class="line">                <span class="string">"SONATYPE_DIR=/opt/sonatype"</span>,</span><br><span class="line">                <span class="string">"NEXUS_HOME=/opt/sonatype/nexus"</span>,</span><br><span class="line">                <span class="string">"NEXUS_DATA=/nexus-data"</span>,</span><br><span class="line">                <span class="string">"NEXUS_CONTEXT="</span>,</span><br><span class="line">                <span class="string">"SONATYPE_WORK=/opt/sonatype/sonatype-work"</span>,</span><br><span class="line">                <span class="string">"DOCKER_TYPE=rh-docker"</span>,</span><br><span class="line">                <span class="string">"INSTALL4J_ADD_VM_PARAMS=-Xms1200m -Xmx1200m -XX:MaxDirectMemorySize=2g -Djava.util.prefs.userRoot=/nexus-data/javaprefs"</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">"Cmd"</span>: [</span><br><span class="line">                <span class="string">"sh"</span>,</span><br><span class="line">                <span class="string">"-c"</span>,</span><br><span class="line">                <span class="string">"<span class="variable">$&#123;SONATYPE_DIR&#125;</span>/start-nexus-repository-manager.sh"</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">"Image"</span>: <span class="string">"sonatype/nexus3"</span>,</span><br><span class="line">            <span class="string">"Volumes"</span>: &#123;</span><br><span class="line">                <span class="string">"/nexus-data"</span>: &#123;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">"WorkingDir"</span>: <span class="string">""</span>,</span><br><span class="line">            <span class="string">"Entrypoint"</span>: null,</span><br><span class="line">            <span class="string">"OnBuild"</span>: null,</span><br><span class="line">            <span class="string">"Labels"</span>: &#123;</span><br><span class="line">                <span class="string">"architecture"</span>: <span class="string">"x86_64"</span>,</span><br><span class="line">                <span class="string">"authoritative-source-url"</span>: <span class="string">"registry.access.redhat.com"</span>,</span><br><span class="line">                <span class="string">"build-date"</span>: <span class="string">"2019-12-10T17:53:44.032126"</span>,</span><br><span class="line">                <span class="string">"com.redhat.build-host"</span>: <span class="string">"cpt-1004.osbs.prod.upshift.rdu2.redhat.com"</span>,</span><br><span class="line">                <span class="string">"com.redhat.component"</span>: <span class="string">"ubi8-container"</span>,</span><br><span class="line">                <span class="string">"com.redhat.license_terms"</span>: <span class="string">"https://www.redhat.com/en/about/red-hat-end-user-license-agreements#UBI"</span>,</span><br><span class="line">                <span class="string">"com.sonatype.license"</span>: <span class="string">"Apache License, Version 2.0"</span>,</span><br><span class="line">                <span class="string">"com.sonatype.name"</span>: <span class="string">"Nexus Repository Manager base image"</span>,</span><br><span class="line">                <span class="string">"description"</span>: <span class="string">"The Universal Base Image is designed and engineered to be the base layer for all of your containerized applications, middleware and utilities. This base image is freely redistributable, but Red Hat only supports Red Hat technologies through subscriptions for Red Hat products. This image is maintained by Red Hat and updated regularly."</span>,</span><br><span class="line">                <span class="string">"distribution-scope"</span>: <span class="string">"public"</span>,</span><br><span class="line">                <span class="string">"io.k8s.description"</span>: <span class="string">"The Universal Base Image is designed and engineered to be the base layer for all of your containerized applications, middleware and utilities. This base image is freely redistributable, but Red Hat only supports Red Hat technologies through subscriptions for Red Hat products. This image is maintained by Red Hat and updated regularly."</span>,</span><br><span class="line">                <span class="string">"io.k8s.display-name"</span>: <span class="string">"Red Hat Universal Base Image 8"</span>,</span><br><span class="line">                <span class="string">"io.openshift.expose-services"</span>: <span class="string">""</span>,</span><br><span class="line">                <span class="string">"io.openshift.tags"</span>: <span class="string">"base rhel8"</span>,</span><br><span class="line">                <span class="string">"maintainer"</span>: <span class="string">"Sonatype &lt;cloud-ops@sonatype.com&gt;"</span>,</span><br><span class="line">                <span class="string">"name"</span>: <span class="string">"ubi8"</span>,</span><br><span class="line">                <span class="string">"release"</span>: <span class="string">"328"</span>,</span><br><span class="line">                <span class="string">"summary"</span>: <span class="string">"Provides the latest release of Red Hat Universal Base Image 8."</span>,</span><br><span class="line">                <span class="string">"url"</span>: <span class="string">"https://access.redhat.com/containers/#/registry.access.redhat.com/ubi8/images/8.1-328"</span>,</span><br><span class="line">                <span class="string">"vcs-ref"</span>: <span class="string">"c42933bcdbf9f1c232e981a5e40de257c3534c8e"</span>,</span><br><span class="line">                <span class="string">"vcs-type"</span>: <span class="string">"git"</span>,</span><br><span class="line">                <span class="string">"vendor"</span>: <span class="string">"Sonatype"</span>,</span><br><span class="line">                <span class="string">"version"</span>: <span class="string">"8.1"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"NetworkSettings"</span>: &#123;</span><br><span class="line">            <span class="string">"Bridge"</span>: <span class="string">""</span>,</span><br><span class="line">            <span class="string">"SandboxID"</span>: <span class="string">"1d4963db1df2a468a4c0afbccf66c45a95c787357a26b3b0fde0437640f38ada"</span>,</span><br><span class="line">            <span class="string">"HairpinMode"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"LinkLocalIPv6Address"</span>: <span class="string">""</span>,</span><br><span class="line">            <span class="string">"LinkLocalIPv6PrefixLen"</span>: 0,</span><br><span class="line">            <span class="string">"Ports"</span>: &#123;</span><br><span class="line">                <span class="string">"8081/tcp"</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="string">"HostIp"</span>: <span class="string">"0.0.0.0"</span>,</span><br><span class="line">                        <span class="string">"HostPort"</span>: <span class="string">"8081"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">"SandboxKey"</span>: <span class="string">"/var/run/docker/netns/1d4963db1df2"</span>,</span><br><span class="line">            <span class="string">"SecondaryIPAddresses"</span>: null,</span><br><span class="line">            <span class="string">"SecondaryIPv6Addresses"</span>: null,</span><br><span class="line">            <span class="string">"EndpointID"</span>: <span class="string">"aa7127e8c0efbd1c713d5700f9fbe6d554f850be5d62c8a1228ed346b37c6abe"</span>,</span><br><span class="line">            <span class="string">"Gateway"</span>: <span class="string">"172.17.0.1"</span>,</span><br><span class="line">            <span class="string">"GlobalIPv6Address"</span>: <span class="string">""</span>,</span><br><span class="line">            <span class="string">"GlobalIPv6PrefixLen"</span>: 0,</span><br><span class="line">            <span class="string">"IPAddress"</span>: <span class="string">"172.17.0.4"</span>,</span><br><span class="line">            <span class="string">"IPPrefixLen"</span>: 16,</span><br><span class="line">            <span class="string">"IPv6Gateway"</span>: <span class="string">""</span>,</span><br><span class="line">            <span class="string">"MacAddress"</span>: <span class="string">"02:42:ac:11:00:04"</span>,</span><br><span class="line">            <span class="string">"Networks"</span>: &#123;</span><br><span class="line">                <span class="string">"bridge"</span>: &#123;</span><br><span class="line">                    <span class="string">"IPAMConfig"</span>: null,</span><br><span class="line">                    <span class="string">"Links"</span>: null,</span><br><span class="line">                    <span class="string">"Aliases"</span>: null,</span><br><span class="line">                    <span class="string">"NetworkID"</span>: <span class="string">"8a339b3fb2f67f78588ee02c15e61e0f4cb21c50c240f2634106a5b2772e068b"</span>,</span><br><span class="line">                    <span class="string">"EndpointID"</span>: <span class="string">"aa7127e8c0efbd1c713d5700f9fbe6d554f850be5d62c8a1228ed346b37c6abe"</span>,</span><br><span class="line">                    <span class="string">"Gateway"</span>: <span class="string">"172.17.0.1"</span>,</span><br><span class="line">                    <span class="string">"IPAddress"</span>: <span class="string">"172.17.0.4"</span>,</span><br><span class="line">                    <span class="string">"IPPrefixLen"</span>: 16,</span><br><span class="line">                    <span class="string">"IPv6Gateway"</span>: <span class="string">""</span>,</span><br><span class="line">                    <span class="string">"GlobalIPv6Address"</span>: <span class="string">""</span>,</span><br><span class="line">                    <span class="string">"GlobalIPv6PrefixLen"</span>: 0,</span><br><span class="line">                    <span class="string">"MacAddress"</span>: <span class="string">"02:42:ac:11:00:04"</span>,</span><br><span class="line">                    <span class="string">"DriverOpts"</span>: null</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>我们重点关注这个：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">"Mounts"</span>: [</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="string">"Type"</span>: <span class="string">"volume"</span>,</span><br><span class="line">               <span class="string">"Name"</span>: <span class="string">"nexus-data"</span>,</span><br><span class="line">               <span class="string">"Source"</span>: <span class="string">"/var/lib/docker/volumes/nexus-data/_data"</span>,</span><br><span class="line">               <span class="string">"Destination"</span>: <span class="string">"/nexus-data"</span>,</span><br><span class="line">               <span class="string">"Driver"</span>: <span class="string">"local"</span>,</span><br><span class="line">               <span class="string">"Mode"</span>: <span class="string">"z"</span>,</span><br><span class="line">               <span class="string">"RW"</span>: <span class="literal">true</span>,</span><br><span class="line">               <span class="string">"Propagation"</span>: <span class="string">""</span></span><br><span class="line">           &#125;</span><br><span class="line">       ],</span><br></pre></td></tr></table></figure>

<p>可以看我source 这个属性，它的值代表的意思是我们本地的/var/lib/docker/volumes/nexus-data/_data目录映射到容器的/nexus-data目录，并且在我们运行容器时指定的相对路径其实是对/var/lib/docker/volumes</p>
<p>来说的，所以我们在来找找这个目录。</p>
<h3 id="var-lib-docker-volumes在哪里"><a href="#var-lib-docker-volumes在哪里" class="headerlink" title="/var/lib/docker/volumes在哪里"></a>/var/lib/docker/volumes在哪里</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 看到这个目录，肯定是一梭子cd /var/lib/docker/volumes</span></span><br><span class="line"><span class="comment"># 但是马上就是</span></span><br><span class="line"><span class="built_in">cd</span>: no such file or directory: /var/lib/docker/volumes/</span><br></pre></td></tr></table></figure>

<p>可以看到的是，我本机下并没有这个目录，但是docker inspect 给出的信息是这样的，那么问题在哪里呢？后来我在想是不是因为系统的缘故？macos和linux 不一样，因为我看到的教程是linux下执行的。为了证实我的猜想，我连上了我的centos服务器。因为我的服务器是安装过docker的，所以可以看看是不是这样的原因。</p>
<p><img src="/2020/02/01/var-lib-docker-volumes-%E5%9C%A8%E5%93%AA%E9%87%8C/image-20200201190223625.png" alt="image-20200201190223625"></p>
<p>这说明在linux系统上是含有这个目录的，我们都知道docker的诞生，依赖的是linux系统提供的cgroups，namespace等基础设施，在centos上因为自带了这些基础设施，所以在运行docker 程序的时候，就可以直接找到那个目录。但是在macos上不一样，甚至在windows上也是不一样的。在macos上，他还是跑了一个vm在上面，这个vm是linux的，在上面跑着docker engine。在macos上我们操作的指令 都会发给这个docker engine。也就是说docker 其实是cs（client-server）类的软件。也就是说，我们运行docker ps -a 或docker 这个命令，其实是客户端的命令。那么我们mac上跑的的vm在哪里呢。</p>
<p>参考链接：<a href="https://forums.docker.com/t/host-path-of-volume/12277" target="_blank" rel="noopener">https://forums.docker.com/t/host-path-of-volume/12277</a></p>
<h3 id="mac-上的vm-virtual-machine"><a href="#mac-上的vm-virtual-machine" class="headerlink" title="mac 上的vm(virtual machine)"></a>mac 上的vm(virtual machine)</h3><p>现在我们知道我们的macos上是跑了一个linux的vm，也就是说我们指定的那个相对目录，其实这个目录应该在那个vm上，那么我们怎么找到它，并进去呢？</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">screen ~/Library/Containers/com.docker.docker/Data/vms/0/tty</span><br></pre></td></tr></table></figure>

<p><img src="/2020/02/01/var-lib-docker-volumes-%E5%9C%A8%E5%93%AA%E9%87%8C/image-20200201201335300.png" alt="image-20200201201335300"></p>
<p>可以看到我们进入了vm，这里使用到了screen命令,用于我们切换进入vm的命令行窗口，这样我们就能在vm中进行操作了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Screen是一款由GNU计划开发的用于命令行终端切换的自由软件。用户可以通过该软件同时连接多个本地或远程的命令行会话，并在其间自由切换。GNU Screen可以看作是窗口管理器的命令行界面版本。它提供了统一的管理多个会话的界面和相应的功能。</span><br><span class="line"></span><br><span class="line">在Screen环境下，所有的会话都独立的运行，并拥有各自的编号、输入、输出和窗口缓存。用户可以通过快捷键在不同的窗口下切换，并可以自由的重定向各个窗口的输入和输出。</span><br></pre></td></tr></table></figure>

<p><img src="/2020/02/01/var-lib-docker-volumes-%E5%9C%A8%E5%93%AA%E9%87%8C/image-20200201201757735.png" alt="image-20200201201757735"></p>
<p>从上面的截图可以看出，我们找到了我们想要的东西了，原来藏在这里。</p>
<p><img src="/2020/02/01/var-lib-docker-volumes-%E5%9C%A8%E5%93%AA%E9%87%8C/image-20200201202046099.png" alt="image-20200201202046099"></p>
<p>可以看到 我们执行docker 是找不到这个命令的，这也印证了我们上面说的，docker 命令其实是客户端的命令，我们是通过docker 客户端命令去和docker engine 通讯的，我们的操作 都会通过这个客户端命令 传给docker engine 来执行，所以有很多相对路径的指定，或者是上下文的指定 其实都是相对于docker engine所在的环境的，这里需要特别注意一下。</p>
<h3 id="指定我们宿主机的绝对路径"><a href="#指定我们宿主机的绝对路径" class="headerlink" title="指定我们宿主机的绝对路径"></a>指定我们宿主机的绝对路径</h3><p>如果我们使用相对路径来指定宿主机到容器的路径映射，那么文件就会存在在docker engine所在的vm中，那么可以把我们宿主机的目录指定进去呢？</p>
<p><img src="/2020/02/01/var-lib-docker-volumes-%E5%9C%A8%E5%93%AA%E9%87%8C/image-20200201204347245.png" alt="image-20200201204347245"></p>
<p>我在本机创建了nexus-data 目录，然后使用命令启动docker 容器，好像并没有启动起来，说我指定的路径包含非法的字符。</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>mount</tag>
      </tags>
  </entry>
  <entry>
    <title>分析一次网关OOM异常</title>
    <url>/2020/01/09/%E5%88%86%E6%9E%90%E4%B8%80%E6%AC%A1%E7%BD%91%E5%85%B3OOM%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>最近的工作是上线一些服务，其中就包括团队开发的网关服务，然而在很早之前，在内网测试的是否并没有可以的关注这个问题，可以说是几乎就没有发现这个问题。然后在内网最后的调试阶段，我们需要把网关和前端的服务调通，这样可以安心的部署上线到外网，但是在相互调试阶段，发现网关服务一直启动不了，或者是启动了之后，前端页面访问无法响应。在排除是不是前端接口调错了接口的情况下，最终我认为问题是出现在网关，查看日志文件发现了出现了OOM问题。</p>
<p><img src="/2020/01/09/%E5%88%86%E6%9E%90%E4%B8%80%E6%AC%A1%E7%BD%91%E5%85%B3OOM%E5%BC%82%E5%B8%B8/image-20200109003347927.png" alt="image-20200109003347927"></p>
<h3 id="拿取内存快照"><a href="#拿取内存快照" class="headerlink" title="拿取内存快照"></a>拿取内存快照</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">小建议： </span><br><span class="line">1. 为了及时保存出现各种jvm内存异常的问题的现场，比较推荐在任何环境下都开启hotspot 虚拟机启动参数</span><br><span class="line">-XX:+HeapDumpOnOutOfMemoryError,可能这个参数不同的虚拟机实现会有不同，但是这里使用hotspot虚拟机举例</span><br><span class="line">2. 对于正在运行的程序，可以使用 jmap 命令，如下：</span><br><span class="line">jmap -dump:live,format=b,file=`<span class="built_in">pwd</span>`/18637.hprof 18637</span><br></pre></td></tr></table></figure>

<p>使用1.的话，程序会在出现OOM错误的情况下自动dump 内存快照，到本地目录，使用2.的话，可以为正在运行的程序dump 一份当前的内存快照信息。</p>
<h3 id="工具分析"><a href="#工具分析" class="headerlink" title="工具分析"></a>工具分析</h3><p>当然了，在远处服务器上的内存快照需要下载到本地，并通关相关的分析工具来分析。这里推荐的有几个：</p>
<ol>
<li>java自带的jvisualvm，这个分析的非常粗糙，界面也不好看</li>
<li>eclipse的MAT分析工具，全称是memory analysis tool</li>
<li>商业工具Jprofile，界面好看，功能强大</li>
</ol>
<h4 id="MAT分析"><a href="#MAT分析" class="headerlink" title="MAT分析"></a>MAT分析</h4><p>打开MAT导入我们的内存dump文件，等待加载完成就可以看到Overview给我们展现的统计信息</p>
<p><img src="/2020/01/09/%E5%88%86%E6%9E%90%E4%B8%80%E6%AC%A1%E7%BD%91%E5%85%B3OOM%E5%BC%82%E5%B8%B8/image-20200109014127015.png" alt="image-20200109014127015"></p>
<p>上面的图显示了分析的结果，可以看到的是mat工具给出的猜测，有两个大小一样的字节数组，尽然有625.1MB，讲道理普通的数组是要不了这么多的内存的。</p>
<p>Problem Suspect 1 说有一个被系统的classloader 装载字节数组的一个实例申请了655468208字节大小的内存。</p>
<p>Proble Suspect 2 说有一个被springboot的LaunchURLClassloader 装在的Http11OutputBuffer类的的实例申请了655460520 字节大小的内存空间，从这可以看出其实这两个字节数组是非常相似的，有可能他们是同一个东西申请的。</p>
<p><img src="/2020/01/09/%E5%88%86%E6%9E%90%E4%B8%80%E6%AC%A1%E7%BD%91%E5%85%B3OOM%E5%BC%82%E5%B8%B8/image-20200109015216380.png" alt="image-20200109015216380"></p>
<p>点击第二个Suspect的detail，我们来查看它的详细情况。</p>
<p><img src="/2020/01/09/%E5%88%86%E6%9E%90%E4%B8%80%E6%AC%A1%E7%BD%91%E5%85%B3OOM%E5%BC%82%E5%B8%B8/image-20200109020339188.png" alt="image-20200109020339188"></p>
<p><img src="/2020/01/09/%E5%88%86%E6%9E%90%E4%B8%80%E6%AC%A1%E7%BD%91%E5%85%B3OOM%E5%BC%82%E5%B8%B8/image-20200109020316166.png" alt="image-20200109020316166"></p>
<p>可以看出这个超大的字节数组，存储的好像是一个字符，包含我们请求的url，似乎还有一些http header信息，我们复制出来看看。</p>
<p><img src="/2020/01/09/%E5%88%86%E6%9E%90%E4%B8%80%E6%AC%A1%E7%BD%91%E5%85%B3OOM%E5%BC%82%E5%B8%B8/image-20200111120215041.png" alt="image-20200111120215041"></p>
<p>嗯确实是一些头信息，但是我们能看到的就只有这些，那么为什么这点数据需要存在那么大的一个字节数组中呢？</p>
<p>我们来使用Jprofile来看看这个字节数组中的内容，看看是不是这个字节数组中全都塞满了数据。</p>
<h4 id="Jprofile分析"><a href="#Jprofile分析" class="headerlink" title="Jprofile分析"></a>Jprofile分析</h4><p><img src="/2020/01/09/%E5%88%86%E6%9E%90%E4%B8%80%E6%AC%A1%E7%BD%91%E5%85%B3OOM%E5%BC%82%E5%B8%B8/image-20200109015248439.png" alt="image-20200109015248439"></p>
<p><img src="/2020/01/09/%E5%88%86%E6%9E%90%E4%B8%80%E6%AC%A1%E7%BD%91%E5%85%B3OOM%E5%BC%82%E5%B8%B8/image-20200109015307497.png" alt="image-20200109015307497"></p>
<p>可以看到的是在0752 行也就是0758位的时候，从这后面存的都是0值，也就是后面的字节数组中存的都是0值，也就是初始化后的值，为啥判断是字节数组初始化的0值呢？ 是因为我断定因该不存在我们人为的去给这么大的字节数组循环的去赋值0，所以我们的问题变成了为什么程序申请了这么一个大字节数组，而只是用到了758位？用编辑器排查了一下程序中new byte[]的行为后，并没有发现程序中有这么直接的行为，所以可以判断有可能是我们程序依赖的代码生成的，所以这个鬼东西再哪里呢？</p>
<h3 id="整个更大的"><a href="#整个更大的" class="headerlink" title="整个更大的"></a>整个更大的</h3><p>回到公司后，我让网关跑久一点，然后dump内存，再分析多一点，这一次我发现我们的内存占用到了6个多G了。</p>
<p><img src="/2020/01/09/%E5%88%86%E6%9E%90%E4%B8%80%E6%AC%A1%E7%BD%91%E5%85%B3OOM%E5%BC%82%E5%B8%B8/image-20200111121550453.png" alt="image-20200111121550453"></p>
<p><img src="/2020/01/09/%E5%88%86%E6%9E%90%E4%B8%80%E6%AC%A1%E7%BD%91%E5%85%B3OOM%E5%BC%82%E5%B8%B8/image-20200111121622315.png" alt="image-20200111121622315"></p>
<p><img src="/2020/01/09/%E5%88%86%E6%9E%90%E4%B8%80%E6%AC%A1%E7%BD%91%E5%85%B3OOM%E5%BC%82%E5%B8%B8/image-20200111121700488.png" alt="image-20200111121700488"></p>
<p><img src="/2020/01/09/%E5%88%86%E6%9E%90%E4%B8%80%E6%AC%A1%E7%BD%91%E5%85%B3OOM%E5%BC%82%E5%B8%B8/image-20200111121749230.png" alt="image-20200111121749230"></p>
<p><img src="/2020/01/09/%E5%88%86%E6%9E%90%E4%B8%80%E6%AC%A1%E7%BD%91%E5%85%B3OOM%E5%BC%82%E5%B8%B8/image-20200111121822581.png" alt="image-20200111121822581"></p>
<p>为什么请求一进来就会被触发呢？ 想一下一个http请求进来发生了什么？一个http请求进来在基于servelet的java web 看来，肯定需要被封装成http的对象，那么http中的对象有什么呢？ </p>
<p><a href="https://www.cnblogs.com/an-wen/p/11180076.html" target="_blank" rel="noopener">HTTP协议超级详解</a></p>
<p><img src="/2020/01/09/%E5%88%86%E6%9E%90%E4%B8%80%E6%AC%A1%E7%BD%91%E5%85%B3OOM%E5%BC%82%E5%B8%B8/image-20200111122512857.png" alt="image-20200111122512857"></p>
<p>我们继续往下看</p>
<p><img src="/2020/01/09/%E5%88%86%E6%9E%90%E4%B8%80%E6%AC%A1%E7%BD%91%E5%85%B3OOM%E5%BC%82%E5%B8%B8/image-20200111121716196.png" alt="image-20200111121716196"></p>
<p><img src="/2020/01/09/%E5%88%86%E6%9E%90%E4%B8%80%E6%AC%A1%E7%BD%91%E5%85%B3OOM%E5%BC%82%E5%B8%B8/image-20200111121737346.png" alt="image-20200111121737346"></p>
<p>我们看到是一个buffer内部的字节数组有这么大，而且名字叫做headerBuffer，嗯奇怪了。为啥有这么大的header呢，我们怀着猜测的想法，去我们的工程中搜索一下是不是有655460xxx这样的数字。</p>
<p><img src="/2020/01/09/%E5%88%86%E6%9E%90%E4%B8%80%E6%AC%A1%E7%BD%91%E5%85%B3OOM%E5%BC%82%E5%B8%B8/image-20200111122930812.png" alt="image-20200111122930812"></p>
<p>上面的注释是我后来加的，卧槽，这竟然真的有这个数字，是这个参数指定的：max-http-header-size。</p>
<p>这个参数是指定最大的http header的大小，也就是说我们设置了这个参数，每一次框架封装http请求的时候就会将我们的http header封装为655460000字节大小，而默认的http header头所占用的字节大小在8k。这也解释了，为啥我们每次请求都会生成这样一个大小的字节数组了。那么我们可能好奇，那么在第一次请求过来，我们的服务器也响应了，那么是不是这个http封装的对象应该被GC掉，因为一次完整的请求-响应都完成了呀？这个问题就要说到我们JVM的GC策略了。有这么一个概念叫做GC root。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">以 GC Roots 为起始点进行搜索，可达的对象都是存活的，不可达的对象可被回收。</span><br><span class="line"></span><br><span class="line">Java 虚拟机使用该算法来判断对象是否可被回收，GC Roots 一般包含以下内容：</span><br><span class="line"></span><br><span class="line">- 虚拟机栈中局部变量表中引用的对象</span><br><span class="line">- 本地方法栈中 JNI 中引用的对象</span><br><span class="line">- 方法区中类静态属性引用的对象</span><br><span class="line">- 方法区中的常量引用的对象</span><br></pre></td></tr></table></figure>

<p>我猜想是不是这写些节数组是被GC root 应用的，所以得不到释放。或者说在还没有执行GC操作的是否就被程序搞的OOM错误，所以JVM没办法正常的执行GC操作？ 我对虚拟机相关的概念也不是非常了解，如果大佬们有其他的见解，欢迎在下方的评论区交流，非常感谢。</p>
<h3 id="解决OOM策略"><a href="#解决OOM策略" class="headerlink" title="解决OOM策略"></a>解决OOM策略</h3><p>如果碰到OOM问题不要慌，使用这些步骤，就算不能药到病除，那也能找到一些关键线索的。</p>
<h4 id="OOM有哪些"><a href="#OOM有哪些" class="headerlink" title="OOM有哪些"></a>OOM有哪些</h4><ul>
<li>java.lang.OutOfMemoryError: heap space</li>
<li>java.lang.OutOfMemoryError: metaspace</li>
<li>java.lang.OutOfMemoryError: PermGen</li>
<li>…</li>
</ul>
<h4 id="碰到OOM问题"><a href="#碰到OOM问题" class="headerlink" title="碰到OOM问题"></a>碰到OOM问题</h4><ul>
<li>深呼吸，天塌不下来</li>
<li>想办法拿到Heap Dump<ul>
<li>开启虚拟机参数 -XX:+HeapDumpOnOutOfMemoryError</li>
<li>jmap -dump:live,format=b,file=·<code>pwd</code>/<pid>.hprof <pid>  （对运行中的程序）</pid></pid></li>
</ul>
</li>
<li>分析之</li>
</ul>
<h4 id="OOM可能的原因"><a href="#OOM可能的原因" class="headerlink" title="OOM可能的原因"></a>OOM可能的原因</h4><ul>
<li>50% 代码问题</li>
<li>40% 配置问题</li>
<li>10% 内存真的不够（加钱？）</li>
<li>以上意味着绝大多数的OOM问题不能通过加内存解决</li>
</ul>
<h4 id="Heap-Dump-分析"><a href="#Heap-Dump-分析" class="headerlink" title="Heap Dump 分析"></a>Heap Dump 分析</h4><ul>
<li>Metaspace/PermGen<ul>
<li>瞄准Class对象</li>
</ul>
</li>
<li>Heap space<ul>
<li>瞄准占用空间最大的对象</li>
</ul>
</li>
<li>Path To GC Roots</li>
<li>顺藤摸瓜去看代码</li>
</ul>
<p>参考：<a href="https://www.bilibili.com/video/av74026881?from=search&amp;seid=445533783958854877" target="_blank" rel="noopener">https://www.bilibili.com/video/av74026881?from=search&amp;seid=445533783958854877</a></p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>删除坑人的注释，重新上线。使用jvisualvm 查看内存GC的情况。</p>
<p><img src="/2020/01/09/%E5%88%86%E6%9E%90%E4%B8%80%E6%AC%A1%E7%BD%91%E5%85%B3OOM%E5%BC%82%E5%B8%B8/image-20200111124506503.png" alt="image-20200111124506503"></p>
<p>可以看到我们的GC正常了，程序也不是一直是高峰内存占用状态。对于配置文件或者配置选项，我的看法是宁缺毋滥，尤其是在没有具体了解配置选项的具体含义的时候，保持最小配置原则，可以让我们对程序有更为清晰的掌控和了解。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>网关</tag>
        <tag>OutOfMemoryError</tag>
      </tags>
  </entry>
  <entry>
    <title>分析服务端netty启动过程</title>
    <url>/2020/01/08/%E5%88%86%E6%9E%90%E6%9C%8D%E5%8A%A1%E7%AB%AFnetty%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p>参数说明:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">netty版本：</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.netty&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;netty-all&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.1.42.Final&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt; </span><br><span class="line">jdk 版本：jdk1<span class="number">.8</span></span><br><span class="line">编辑器：IDEA2019<span class="number">.3</span></span><br><span class="line">平台：macos</span><br></pre></td></tr></table></figure>

<p>相关类：</p>
<p><img src="/2020/01/08/%E5%88%86%E6%9E%90%E6%9C%8D%E5%8A%A1%E7%AB%AFnetty%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/image-20200108010140871.png" alt="image-20200108010140871"></p>
<p>可以看到的是我们的服务器代码结构和客户端的结构几乎是相同的，现在我们来看看服务端具体的类代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyTimeServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> port = <span class="number">8888</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//启动boss事件循环组</span></span><br><span class="line">        NioEventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">      	<span class="comment">//启动work事件循环组</span></span><br><span class="line">        NioEventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            bootstrap.group(bossGroup,workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                    .<span class="title">option</span>(<span class="title">ChannelOption</span>.<span class="title">SO_BACKLOG</span>,1024)</span></span><br><span class="line"><span class="class">                    .<span class="title">childHandler</span>(<span class="title">new</span> <span class="title">NettyChildChannelInitializer</span>())</span>;</span><br><span class="line">            <span class="comment">//绑定端口，同步等待成功</span></span><br><span class="line">            ChannelFuture future = bootstrap.bind(port).sync();</span><br><span class="line">            <span class="comment">//等待服务端监听的端口关闭</span></span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>。。。未完待续。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>netty</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo-Typora整合</title>
    <url>/2019/12/29/Hexo-Typora%E6%95%B4%E5%90%88/</url>
    <content><![CDATA[<p>写markdwon 文档首推typora，那种wyswyg的感觉是真的爽，我们的静态博客也是使用markdwon来编写的，比如hexo，所以如果可以将两者结合那将会是非常爽的事。这篇整合的笔记，还是因为我在发布我的hexo博客的是否，发现在博客文章页面是可以显示图的，但是点击图片就显示不出，原因一看就是出在图片的路径上。</p>
<p><img src="/2019/12/29/Hexo-Typora%E6%95%B4%E5%90%88/image-20191229231450217.png" alt="image-20191229231450217"></p>
<p>点击之后：</p>
<p><img src="/2019/12/29/Hexo-Typora%E6%95%B4%E5%90%88/image-20191229231512705.png" alt="image-20191229231512705"></p>
<p>经过一番研究，找到了一下的解决方案</p>
<h3 id="安装hexo-asset-image插件"><a href="#安装hexo-asset-image插件" class="headerlink" title="安装hexo-asset-image插件"></a>安装hexo-asset-image插件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">在博客根目录运行</span><br><span class="line">yarn add hexo-asset-image </span><br><span class="line">等待插件安装完成</span><br></pre></td></tr></table></figure>

<h3 id="开启配置"><a href="#开启配置" class="headerlink" title="开启配置"></a>开启配置</h3><p>修改博客根目录下的_config.yml 文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">post_asset_folder: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h3 id="修改post-md-模版"><a href="#修改post-md-模版" class="headerlink" title="修改post.md 模版"></a>修改post.md 模版</h3><p>为啥要修改post模版呢？ 我们要和typora整合，typora在写md文档时可以识别我们标题头的配置文件，把图片的根路径设置和我们制定的路径一样，这样我们在typora中黏贴图片，就会和我们制定的目录对应上。</p>
<p>找到根目录下的文件夹，修改post 为一下内容。<img src="/2019/12/29/Hexo-Typora%E6%95%B4%E5%90%88/image-20191229232113126.png" alt="image-20191229232113126"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">tags:</span><br><span class="line">  - </span><br><span class="line">  - </span><br><span class="line">categories:</span><br><span class="line">  - x</span><br><span class="line">description: </span><br><span class="line">  - x</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">typora-root-url: &#123;&#123; title &#125;&#125;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h3 id="设置typora"><a href="#设置typora" class="headerlink" title="设置typora"></a>设置typora</h3><p><img src="/2019/12/29/Hexo-Typora%E6%95%B4%E5%90%88/image-20191229232240970.png" alt="image-20191229232240970"></p>
<p>发现这样鼓捣之后，还是达不到效果，而且默认生成的页面中的图片url 前缀带有io什么鬼，搜索全网找到了问题所在，原来是 hexo-asset-image  这个插件有一个bug。</p>
<blockquote>
<p>图片路径会从原本/xxx.jpg变成 /.io/xxx.jpg](<a href="https://github.com/xcodebuild/hexo-asset-image/issues/47#" target="_blank" rel="noopener">https://github.com/xcodebuild/hexo-asset-image/issues/47#</a>)</p>
</blockquote>
<p>解决的方法就是找到hexo-asset-image 这个包下面的index.js ,修改24行的源码为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> endPos = link.length - <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>最终问题解决，皆大欢喜。</p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>花了一个周末，终于整好了一个看起来还行的blog，还行还行。s</p>
]]></content>
      <categories>
        <category>折腾日记</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo-blog开启自定义域名</title>
    <url>/2019/12/29/Hexo-blog%E5%BC%80%E5%90%AF%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D/</url>
    <content><![CDATA[<p>在我们搭建好了我们的hexo + next 主题的博客之后，我们的访问域名是githubid.github.io, 这显然没办法满足我们的要求，我们需要一个别具一格的域名。</p>
<h3 id="域名申请注册"><a href="#域名申请注册" class="headerlink" title="域名申请注册"></a>域名申请注册</h3><p>实用工具查找了很多域名提供商，国内的不考虑，国外的狗爹，namecheap，namesilo等，最终我选择了namesilo，因为续费比较便宜，支持支付宝，方便支付，而且可能还能碰上打折什么的，岂不美哉。</p>
<blockquote>
<p><a href="https://namebeta.com/search/fireinrain" target="_blank" rel="noopener">https://namebeta.com/search/fireinrain</a> 域名价格比对</p>
</blockquote>
<p><a href="[https://www.namesilo.com](https://www.namesilo.com/)">NameSilo</a></p>
<p>按照流程注册一个用户，然后去Domain那边查找自己想要的域名</p>
<p><img src="/2019/12/29/Hexo-blog%E5%BC%80%E5%90%AF%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D/image-20191229210617942.png" alt="image-20191229210617942"></p>
<p><img src="/2019/12/29/Hexo-blog%E5%BC%80%E5%90%AF%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D/image-20191229210640856.png" alt="image-20191229210640856"></p>
<p>填好玩必要的注册信息后，点击注册即可。</p>
<h3 id="域名选择"><a href="#域名选择" class="headerlink" title="域名选择"></a>域名选择</h3><p><img src="/2019/12/29/Hexo-blog%E5%BC%80%E5%90%AF%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D/image-20191229210843982.png" alt="image-20191229210843982"></p>
<p>点击搜索，选择好域名</p>
<p><img src="/2019/12/29/Hexo-blog%E5%BC%80%E5%90%AF%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D/image-20191229211000279.png" alt="image-20191229211000279"></p>
<h3 id="购买域名"><a href="#购买域名" class="headerlink" title="购买域名"></a>购买域名</h3><p>跳转至购买页面后，可以设置购买时间等，在Promotion Code输入优惠码(网上搜一下)，点击submit可以优惠1美元，设置完成后点击continue</p>
<p><img src="/2019/12/29/Hexo-blog%E5%BC%80%E5%90%AF%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D/image-20191229211203919.png" alt="image-20191229211203919"></p>
<p>点击下面的continue 按钮，跳转到支付页面。</p>
<p><img src="/2019/12/29/Hexo-blog%E5%BC%80%E5%90%AF%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D/image-20191229211333933.png" alt="image-20191229211333933"></p>
<p>输入自己的支付宝邮箱账号，点击go 付款即可。</p>
<h3 id="设置DNS解析"><a href="#设置DNS解析" class="headerlink" title="设置DNS解析"></a>设置DNS解析</h3><p><img src="/2019/12/29/Hexo-blog%E5%BC%80%E5%90%AF%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D/image-20191229211457920.png" alt="image-20191229211457920"></p>
<p>点击小圆球，进入DNS设置界面。添加一个github 模版</p>
<p><img src="/2019/12/29/Hexo-blog%E5%BC%80%E5%90%AF%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D/image-20191229211709741.png" alt="image-20191229211709741"></p>
<p>这个设置会自动帮你设置github的相关ip解析，你需要做的就是修改CNAME记录，为自己的github pages地址</p>
<p><img src="/2019/12/29/Hexo-blog%E5%BC%80%E5%90%AF%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D/image-20191229211914264.png" alt="image-20191229211914264"></p>
<p>修改后提交即可，我们在namesilo的设置就算结束了。</p>
<h3 id="github-io-设置"><a href="#github-io-设置" class="headerlink" title="github.io 设置"></a>github.io 设置</h3><p>进入到我们博客的根目录，在source 文件夹下面创建一个CNAME 文件，内容就是我们申请的域名</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> my-blog-site</span><br><span class="line"><span class="built_in">cd</span>  <span class="built_in">source</span></span><br><span class="line">touch CNAME</span><br><span class="line"><span class="comment"># 将一下内容加入</span></span><br><span class="line">fireinrain.com</span><br><span class="line"></span><br><span class="line">hexo clean</span><br><span class="line">hexo g &amp; hexo d</span><br></pre></td></tr></table></figure>

<p>重写部署我们的网站。</p>
<p>DNS解析到记录可能需要一定的时间，有时候很快，有时候要等上几个小时，所以一开始就访问我们的自定义域名没反应不要慌。</p>
<p>去github进入我们的博客代码仓库，点击setting选项，查看自定义域名的情况和CNAME的情况，我们自定义的域名其实也是可以加上小绿锁的(https)</p>
<p><img src="/2019/12/29/Hexo-blog%E5%BC%80%E5%90%AF%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D/image-20191229212646350.png" alt="image-20191229212646350"></p>
<p>如果小绿锁没有开启，按照官方提示，进行如下操作：</p>
<p>把 Custom domain 中的值清空，并点击 Save 进行保存；<br>在 Custom domain 中的填入之前清空的值，我这里是 fireinrain.com ，填入后点击保存；<br>尝试在浏览器里主动访问 <a href="https://fireinrain.com" target="_blank" rel="noopener">https://fireinrain.com</a> ，地址要根据自己的情况，注意协议类型是 https，正确情况下是能正常访问的；<br>刷新项目设置页，如果 enforce HTTPS 可勾选，勾选即可；<br>如果 enforce HTTPS 不可勾选，并且提示 Not yet available for your site because the certificate has not finished being issued” ，说明证书尚未申请完成，等待一天即可。</p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>也没啥后记的，努力写博客吧！</p>
]]></content>
      <categories>
        <category>折腾日记</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Namesilo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo+Next主题折腾</title>
    <url>/2019/12/29/Hexo-Next%E4%B8%BB%E9%A2%98%E6%8A%98%E8%85%BE/</url>
    <content><![CDATA[<h3 id="安装nodejs环境"><a href="#安装nodejs环境" class="headerlink" title="安装nodejs环境"></a>安装nodejs环境</h3><p>因为hexo是js写的，需要nodejs 执行环境，所以我们必须安装nodejs 环境。</p>
<p>没什么特别的，直接去nodejs 官网下载对应系统的安装包，这里我使用的是macos，所以直接 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install node</span><br></pre></td></tr></table></figure>
<p>由于npm 时不时会出些幺蛾子，所以这里推荐yarn来安装工程的相关依赖。</p>
<h4 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn global add hexo-cli</span><br></pre></td></tr></table></figure>

<p>在我们喜欢的目录下，创建一个文件夹，名字可以叫my-blog-site，然后进入该目录。执行hexo 初始化命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir my-blog-site</span><br><span class="line"><span class="built_in">cd</span> my-blog-site</span><br><span class="line">hexo init</span><br></pre></td></tr></table></figure>

<p>等待hexo 执行完成，然后执行hexo s（hexo server），打开浏览器，访问<a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a>  就可以看到我们的博客啦！🍻</p>
<p>官方是使用 npm 进行安装，个人推荐使用 yarn进行安装，关于 yarn 和 npm 优劣分析，可以参考这篇文章Yarn vs npm: 你需要知道的一切 <a href="http://web.jobbole.com/88459/" target="_blank" rel="noopener">http://web.jobbole.com/88459/</a></p>
<h3 id="部署hexo博客到github"><a href="#部署hexo博客到github" class="headerlink" title="部署hexo博客到github"></a>部署hexo博客到github</h3><p>首先需要去主持github 账号，然后创建一个yourGithubId.github.io 的仓库，yourGithubId 是你的github账号id，有了这个之后在执行下面的操作。</p>
<p>下载 <code>hexo-deployer-git</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在博客根目录执行</span></span><br><span class="line">yarn add hexo-deployer-git</span><br></pre></td></tr></table></figure>

<p>找到博客根目录的_config.yml,修改内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo: https://github.com/yourgithubid/yougithub</span><br><span class="line">  branch: master</span><br><span class="line">  message: aha, I have update my blog 🍺</span><br></pre></td></tr></table></figure>

<p>在根目录执行 hexo g &amp; hexo d（hexo generate &amp; hexo deploy），可能会提示我们需要github 的账号和密码，我们按照指示填入即可，等待操作完成，然后访问yourgithubid.github.io,嗯我们的博客出现了。</p>
<p>不过这个博客的样式有些单调，难免让人提不起兴趣，所以呢，就让我们把它玩坏吧（不是），给她穿上美丽的衣服吧。</p>
<h3 id="next-主题安装"><a href="#next-主题安装" class="headerlink" title="next 主题安装"></a>next 主题安装</h3><p>其实看了好多主题，有些花里胡哨的，有些是极致简约的，有的是日常更新，有的又是年久失修，所以选来选去还是选老牌简约，更新及时的，因为这样主题一些相关的bug可以得到及时的处理，而且还有一个有点就是美化教程多啊，这样我们鼓捣的成本就会地点，遇到坑去寻找解决办法有很大概率能找到。（其实博客也没必要那么花里胡哨，博客本质还是要看你的内容，其余的不是非常重要）</p>
<h4 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在更目录下执行</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>

<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>修改根目录下的_config.yml 文件中theme 选项</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：这里的_config.yml 文件有两个，一个是根目录下的，一个是theme/yourtheme/_config.yml 文件，相当于一个是主配置，一个是子配置</p>
</blockquote>
<h3 id="美化配置"><a href="#美化配置" class="headerlink" title="美化配置"></a>美化配置</h3><h4 id="设置网站语言"><a href="#设置网站语言" class="headerlink" title="设置网站语言"></a>设置网站语言</h4><p>找到我们的主配置文件，修改：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">language: zh-CN</span><br></pre></td></tr></table></figure>

<h4 id="增加栏目"><a href="#增加栏目" class="headerlink" title="增加栏目"></a>增加栏目</h4><p>修改主题配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || home</span><br><span class="line">  <span class="comment">#about: /about/ || user</span></span><br><span class="line">  <span class="comment">#tags: /tags/ || tags</span></span><br><span class="line">  <span class="comment">#categories: /categories/ || th</span></span><br><span class="line">  archives: /archives/ || archive</span><br><span class="line">  <span class="comment">#schedule: /schedule/ || calendar</span></span><br><span class="line">  <span class="comment">#sitemap: /sitemap.xml || sitemap</span></span><br><span class="line">  <span class="comment">#commonweal: /404/ || heartbeat</span></span><br><span class="line"><span class="comment">#我们需要几个就放开相关的注释</span></span><br></pre></td></tr></table></figure>

<h4 id="选择Next主题风格"><a href="#选择Next主题风格" class="headerlink" title="选择Next主题风格"></a>选择Next主题风格</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Schemes</span></span><br><span class="line"><span class="comment"># scheme: Muse</span></span><br><span class="line">scheme: Mist</span><br><span class="line"><span class="comment"># scheme: Pisces</span></span><br><span class="line"><span class="comment"># scheme: Gemini</span></span><br></pre></td></tr></table></figure>

<p><img src="/2019/12/29/Hexo-Next%E4%B8%BB%E9%A2%98%E6%8A%98%E8%85%BE/image-20191229123128574.png" alt="image-20191229123128574"></p>
<h4 id="为菜单加上默认页面"><a href="#为菜单加上默认页面" class="headerlink" title="为菜单加上默认页面"></a>为菜单加上默认页面</h4><p>目前我们的分类 标签 关于都是默认404 页面 我们需要给一个默认页面，在根目录分别执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page <span class="string">"categories"</span></span><br><span class="line">hexo new page <span class="string">"tags"</span></span><br><span class="line">hexo new page <span class="string">"about"</span></span><br><span class="line"><span class="comment"># 分别编辑</span></span><br></pre></td></tr></table></figure>

<p><img src="/2019/12/29/Hexo-Next%E4%B8%BB%E9%A2%98%E6%8A%98%E8%85%BE/image-20191229124219603.png" alt="image-20191229124219603"></p>
<p>为对应的类型。这样我们的栏目就有默认页面了。</p>
<h4 id="网站图标设置"><a href="#网站图标设置" class="headerlink" title="网站图标设置"></a>网站图标设置</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">图标素材网站：iconfont；easyicon</span><br><span class="line">下载16x16以及32x32大小的PNG格式图标，置于/themes/next/<span class="built_in">source</span>/images/下</span><br><span class="line">打开**themes/next/下的_config.yml**，查找favicon</span><br><span class="line"></span><br><span class="line">favicon:</span><br><span class="line">  small: /images/favicon-16x16-next.png</span><br><span class="line">  medium: /images/favicon-32x32-next.png</span><br><span class="line">  apple_touch_icon: /images/apple-touch-icon-next.png</span><br><span class="line">  safari_pinned_tab: /images/logo.svg</span><br><span class="line">  <span class="comment">#android_manifest: /images/manifest.json</span></span><br><span class="line">  <span class="comment">#ms_browserconfig: /images/browserconfig.xml</span></span><br></pre></td></tr></table></figure>

<h4 id="设置头像"><a href="#设置头像" class="headerlink" title="设置头像"></a>设置头像</h4><p>打开<code>themes/next/</code>下的<code>_config.yml</code>，查找<code>avatar</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">avatar:</span><br><span class="line">  <span class="comment"># Replace the default image and set the url here.</span></span><br><span class="line">  url: /images/avatar.jpg</span><br><span class="line">  <span class="comment"># If true, the avatar will be dispalyed in circle.</span></span><br><span class="line">  rounded: <span class="literal">true</span></span><br><span class="line">  <span class="comment"># If true, the avatar will be rotated with the cursor.</span></span><br><span class="line">  rotated: <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h4 id="添加背景动画"><a href="#添加背景动画" class="headerlink" title="添加背景动画"></a>添加背景动画</h4><p>安装依赖</p>
<p>cd theme/next</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/theme-next-canvas-ribbon <span class="built_in">source</span>/lib/canvas-ribbon</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Canvas-ribbon</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/theme-next/theme-next-canvas-ribbon</span></span><br><span class="line"><span class="comment"># For more information: https://github.com/zproo/canvas-ribbon</span></span><br><span class="line">canvas_ribbon:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  size: 300 <span class="comment"># The width of the ribbon</span></span><br><span class="line">  alpha: 0.6 <span class="comment"># The transparency of the ribbon</span></span><br><span class="line">  zIndex: -1 <span class="comment"># The display level of the ribbon</span></span><br></pre></td></tr></table></figure>

<h4 id="底部显示建站时间"><a href="#底部显示建站时间" class="headerlink" title="底部显示建站时间"></a>底部显示建站时间</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Specify the date when the site was setup</span></span><br><span class="line">since: 2018 <span class="comment"># 建站年份</span></span><br></pre></td></tr></table></figure>



<h4 id="开启social-链接"><a href="#开启social-链接" class="headerlink" title="开启social 链接"></a>开启social 链接</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">social:</span><br><span class="line">  GitHub: https://github.com/lzhaoyang || github</span><br><span class="line">  <span class="comment">#E-Mail: mailto:yourname@gmail.com || envelope</span></span><br><span class="line">  <span class="comment">#Weibo: https://weibo.com/yourname || weibo</span></span><br><span class="line">  <span class="comment">#Google: https://plus.google.com/yourname || google</span></span><br><span class="line">  <span class="comment">#Twitter: https://twitter.com/yourname || twitter</span></span><br><span class="line">  <span class="comment">#FB Page: https://www.facebook.com/yourname || facebook</span></span><br><span class="line">  <span class="comment">#StackOverflow: https://stackoverflow.com/yourname || stack-overflow</span></span><br><span class="line">  <span class="comment">#YouTube: https://youtube.com/yourname || youtube</span></span><br><span class="line">  <span class="comment">#Instagram: https://instagram.com/yourname || instagram</span></span><br><span class="line">  <span class="comment">#Skype: skype:yourname?call|chat || skype</span></span><br><span class="line">  <span class="comment">#RSS: /atom.xml || rss</span></span><br></pre></td></tr></table></figure>

<h4 id="设置代码块高亮主题"><a href="#设置代码块高亮主题" class="headerlink" title="设置代码块高亮主题"></a>设置代码块高亮主题</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">codeblock:</span><br><span class="line">  <span class="comment"># Code Highlight theme</span></span><br><span class="line">  <span class="comment"># Available values: normal | night | night eighties | night blue | night bright | solarized | solarized dark | galactic</span></span><br><span class="line">  <span class="comment"># See: https://github.com/chriskempson/tomorrow-theme</span></span><br><span class="line">  highlight_theme: night eighties</span><br><span class="line">  <span class="comment"># Add copy button on codeblock</span></span><br><span class="line">  copy_button:</span><br><span class="line">    <span class="built_in">enable</span>: <span class="literal">false</span></span><br><span class="line">    <span class="comment"># Show text copy result.</span></span><br><span class="line">    show_result: <span class="literal">false</span></span><br><span class="line">    <span class="comment"># Available values: default | flat | mac</span></span><br><span class="line">    style:</span><br></pre></td></tr></table></figure>

<h4 id="设置阅读进度"><a href="#设置阅读进度" class="headerlink" title="设置阅读进度"></a>设置阅读进度</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Reading progress bar</span></span><br><span class="line">reading_progress:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Available values: top | bottom</span></span><br><span class="line">  position: top</span><br><span class="line">  color: <span class="string">"#37c6c0"</span></span><br><span class="line">  height: 3px</span><br></pre></td></tr></table></figure>

<h4 id="开启书签标记"><a href="#开启书签标记" class="headerlink" title="开启书签标记"></a>开启书签标记</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Reading progress bar</span></span><br><span class="line">reading_progress:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Available values: top | bottom</span></span><br><span class="line">  position: top</span><br><span class="line">  color: <span class="string">"#37c6c0"</span></span><br><span class="line">  height: 3px</span><br></pre></td></tr></table></figure>

<h4 id="开启github-bannner"><a href="#开启github-bannner" class="headerlink" title="开启github bannner"></a>开启github bannner</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">github_banner:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  permalink: https://github.com/lzhaoyang</span><br><span class="line">  title: Follow me on GitHub</span><br></pre></td></tr></table></figure>

<h4 id="开启本地搜索"><a href="#开启本地搜索" class="headerlink" title="开启本地搜索"></a>开启本地搜索</h4><p>安装依赖</p>
<p>yarn add hexo-generator-searchdb</p>
<p>修改主配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  content: <span class="literal">true</span></span><br><span class="line">  format: html</span><br></pre></td></tr></table></figure>

<p>修改子配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Local Search</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/theme-next/hexo-generator-searchdb</span></span><br><span class="line">local_search:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  <span class="comment"># If auto, trigger search by changing input.</span></span><br><span class="line">  <span class="comment"># If manual, trigger search by pressing enter key or search button.</span></span><br><span class="line">  trigger: auto</span><br><span class="line">  <span class="comment"># Show top n results per article, show all results by setting to -1</span></span><br><span class="line">  top_n_per_article: 1</span><br><span class="line">  <span class="comment"># Unescape html strings to the readable one.</span></span><br><span class="line">  unescape: <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Preload the search data when the page loads.</span></span><br><span class="line">  preload: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h4 id="开启打赏"><a href="#开启打赏" class="headerlink" title="开启打赏"></a>开启打赏</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Reward (Donate)</span></span><br><span class="line"><span class="comment"># Front-matter variable (unsupport animation).</span></span><br><span class="line">reward_settings:</span><br><span class="line">  <span class="comment"># If true, reward will be displayed in every article by default.</span></span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  animation: <span class="literal">false</span></span><br><span class="line">  comment: 坚持原创技术分享，您的支持将鼓励我继续创作！</span><br><span class="line"></span><br><span class="line">reward:</span><br><span class="line">  wechatpay: /images/wechatpay.png</span><br><span class="line">  alipay: /images/alipay.png</span><br><span class="line">  <span class="comment">#bitcoin: /images/bitcoin.png</span></span><br></pre></td></tr></table></figure>

<h4 id="开启不蒜子统计"><a href="#开启不蒜子统计" class="headerlink" title="开启不蒜子统计"></a>开启不蒜子统计</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Show Views / Visitors of the website / page with busuanzi.</span></span><br><span class="line"><span class="comment"># Get more information on http://ibruce.info/2015/04/04/busuanzi</span></span><br><span class="line">busuanzi_count:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  total_visitors: <span class="literal">true</span></span><br><span class="line">  total_visitors_icon: user</span><br><span class="line">  total_views: <span class="literal">true</span></span><br><span class="line">  total_views_icon: eye</span><br><span class="line">  post_views: <span class="literal">true</span></span><br><span class="line">  post_views_icon: eye</span><br></pre></td></tr></table></figure>

<h4 id="安装一个看板娘"><a href="#安装一个看板娘" class="headerlink" title="安装一个看板娘"></a>安装一个看板娘</h4><p>安装依赖：</p>
<p>yarn add hexo-helper-live2d</p>
<p>安装模型文件</p>
<p>yarn add live2d-widget-model-koharu</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">在根目录下创建一个 live2d-models 文件夹，去node_modules 找到我们的模型文件夹live2d-widget-model-koharu</span><br><span class="line">整个复制到live2d-models</span><br><span class="line">修改主配置文件，加入一下内容</span><br><span class="line"><span class="comment"># live2d setting</span></span><br><span class="line">live2d:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  scriptFrom: <span class="built_in">local</span></span><br><span class="line">  pluginRootPath: live2dw/</span><br><span class="line">  pluginJsPath: lib/</span><br><span class="line">  pluginModelPath: assets/</span><br><span class="line">  model:</span><br><span class="line">    use: live2d-widget-model-koharu</span><br><span class="line">    <span class="comment">#live2d-widget-model-hijiki</span></span><br><span class="line">    hHeadPos: 0.5</span><br><span class="line">    vHeadPos: 0.618</span><br><span class="line">  display:</span><br><span class="line">    width: 200</span><br><span class="line">    height: 350</span><br><span class="line">    position: right</span><br><span class="line">    hOffset: -10</span><br><span class="line">    vOffset: -10</span><br><span class="line">  mobile:</span><br><span class="line">    show: <span class="literal">true</span></span><br><span class="line">    scale: 0.2</span><br></pre></td></tr></table></figure>

<h4 id="开启版权声明"><a href="#开启版权声明" class="headerlink" title="开启版权声明"></a>开启版权声明</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">creative_commons:</span><br><span class="line">  license: by-nc-sa</span><br><span class="line">  sidebar: <span class="literal">false</span></span><br><span class="line">  post: <span class="literal">true</span></span><br><span class="line">  language: zh-CN</span><br></pre></td></tr></table></figure>

<h4 id="添加字数统计阅读统计"><a href="#添加字数统计阅读统计" class="headerlink" title="添加字数统计阅读统计"></a>添加字数统计阅读统计</h4><p>安装依赖：</p>
<p>yarn add hexo-symbols-count-time</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Post wordcount display settings</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/theme-next/hexo-symbols-count-time</span></span><br><span class="line">symbols_count_time:</span><br><span class="line">  separated_meta: <span class="literal">true</span></span><br><span class="line">  item_text_post: <span class="literal">true</span></span><br><span class="line">  item_text_total: <span class="literal">true</span></span><br><span class="line">  awl: 4</span><br><span class="line">  wpm: 275</span><br></pre></td></tr></table></figure>

<h4 id="和typora-整合加入图片"><a href="#和typora-整合加入图片" class="headerlink" title="和typora 整合加入图片"></a>和typora 整合加入图片</h4><p>在source 目录新建一个images 文件夹，修改typora 系统设置如图：</p>
<p><img src="/2019/12/29/Hexo-Next%E4%B8%BB%E9%A2%98%E6%8A%98%E8%85%BE/image-20191229182620384.png" alt="image-20191229182620384"></p>
<p>这样我们我们的source 目录用typora打开，在插入图片时，图片会自动拷贝到images 相关目录下，hexo 不用做相关配置。</p>
<h4 id="设置我们的写作模版"><a href="#设置我们的写作模版" class="headerlink" title="设置我们的写作模版"></a>设置我们的写作模版</h4><p>找到scaffolds文件夹下的post.md,修改为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">tags:</span><br><span class="line">  - </span><br><span class="line">  - </span><br><span class="line">categories:</span><br><span class="line">  - x</span><br><span class="line">description: </span><br><span class="line">  - x</span><br><span class="line"></span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h4 id="添加阅读结束"><a href="#添加阅读结束" class="headerlink" title="添加阅读结束"></a>添加阅读结束</h4><p>给文章后面添加结束标语</p>
<h5 id="新建文件"><a href="#新建文件" class="headerlink" title="新建文件"></a>新建文件</h5><p>在<code>\themes\next\layout\_macro</code>中新建<code>passage-end-tag.swig</code>文件，添加代码至该文件中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &#123;% <span class="keyword">if</span> not is_index %&#125;</span><br><span class="line">        &lt;div style=<span class="string">"text-align:center;color: #ccc;font-size:14px;"</span>&gt;-------------本文结束&lt;i class=<span class="string">"fa fa-paw"</span>&gt;&lt;/i&gt;感谢您的阅读-------------&lt;/div&gt;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<h5 id="修改post-swig"><a href="#修改post-swig" class="headerlink" title="修改post.swig"></a>修改post.swig</h5><p>打开<code>\themes\next\layout\_macro\post.swig</code>文件，在<code>post-body</code>后，<code>post-footer</code>前，添加下面内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &#123;% <span class="keyword">if</span> not is_index %&#125;</span><br><span class="line">    &#123;% include <span class="string">'passage-end-tag.swig'</span> %&#125;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<h6 id="修改-config"><a href="#修改-config" class="headerlink" title="修改_config"></a>修改_config</h6><p>打开主题配置文件（<code>_config.yml</code>),在末尾添加：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 文章末尾添加“本文结束”标记</span></span><br><span class="line">passage_end_tag:</span><br><span class="line">  enabled: <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>至此，就完成了关于添加文章结束标语的功能，具体的效果，此刻，想必你也看到了，就在下边。</p>
<h4 id="添加gitalk-评论"><a href="#添加gitalk-评论" class="headerlink" title="添加gitalk 评论"></a>添加gitalk 评论</h4><p>首先我们需要去我们的github上，在个人setting 进行如下操作：</p>
<p><img src="/2019/12/29/Hexo-Next%E4%B8%BB%E9%A2%98%E6%8A%98%E8%85%BE/image-20191229165359360.png" alt="image-20191229165359360"></p>
<p>点击注册application，等待后续使用</p>
<p><img src="/2019/12/29/Hexo-Next%E4%B8%BB%E9%A2%98%E6%8A%98%E8%85%BE/image-20191229165606519.png" alt="image-20191229165606519"></p>
<p>回到我门的子配置文件，找到gitalk配置，进行如下修改：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Multiple Comment System Support</span></span><br><span class="line">comments:</span><br><span class="line">  <span class="comment"># Available values: tabs | buttons</span></span><br><span class="line">  style: tabs</span><br><span class="line">  <span class="comment"># Choose a comment system to be displayed by default.</span></span><br><span class="line">  <span class="comment"># Available values: changyan | disqus | disqusjs | gitalk | livere | valine</span></span><br><span class="line">  active: gitalk</span><br><span class="line">  <span class="comment"># Setting `true` means remembering the comment system selected by the visitor.</span></span><br><span class="line">  storage: <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Lazyload all comment systems.</span></span><br><span class="line">  lazyload: <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Modify texts or order for any navs, here are some examples.</span></span><br><span class="line">  nav:</span><br><span class="line">    <span class="comment">#disqus:</span></span><br><span class="line">    <span class="comment">#  text: Load Disqus</span></span><br><span class="line">    <span class="comment">#  order: -1</span></span><br><span class="line">    gitalk:</span><br><span class="line">      order: -2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># For more information: https://gitalk.github.io, https://github.com/gitalk/gitalk</span></span><br><span class="line">gitalk:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  github_id: * <span class="comment"># GitHub repo owner</span></span><br><span class="line">  repo: * <span class="comment"># Repository name to store issues</span></span><br><span class="line">  client_id: * <span class="comment"># GitHub Application Client ID</span></span><br><span class="line">  client_secret: * <span class="comment"># GitHub Application Client Secret</span></span><br><span class="line">  admin_user: * <span class="comment"># GitHub repo owner and collaborators, only these guys can initialize gitHub issues</span></span><br><span class="line">  distraction_free_mode: <span class="literal">true</span> <span class="comment"># Facebook-like distraction free mode</span></span><br><span class="line">  <span class="comment"># Gitalk's display language depends on user's browser or system environment</span></span><br><span class="line">  <span class="comment"># If you want everyone visiting your site to see a uniform language, you can set a force language value</span></span><br><span class="line">  <span class="comment"># Available values: en | es-ES | fr | ru | zh-CN | zh-TW</span></span><br><span class="line">  language: zh-CN</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 注意* 表示自己替换相关的配置</span></span><br></pre></td></tr></table></figure>

<p>hexo clean 清除本地缓存，然后hexo g &amp; hexo d 推送到github，我们访问我门的博客就可以看到效果了。 </p>
<p>需要注意的是如果你在typora 中写了md，然后复制到你的博客目录下，然后在编译博客，可能会出现这种错误：</p>
<p><img src="/2019/12/29/Hexo-Next%E4%B8%BB%E9%A2%98%E6%8A%98%E8%85%BE/image-20191229174817117.png" alt="image-20191229174817117"></p>
<p>需要注意我们这里的md 头部有注释</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 图片测试</span><br><span class="line">tags:</span><br><span class="line">  - null</span><br><span class="line">  - null</span><br><span class="line">categories:</span><br><span class="line">  - x</span><br><span class="line">description:</span><br><span class="line">  - x</span><br><span class="line">date: 2019-12-29 16:32:39</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>需要加上这个才能通过hexo的编译，出现问题不要慌，耐心解决问题就好了</p>
<h4 id="加入文章总字数统计"><a href="#加入文章总字数统计" class="headerlink" title="加入文章总字数统计"></a>加入文章总字数统计</h4><p>效果如下：</p>
<p><img src="/2019/12/29/Hexo-Next%E4%B8%BB%E9%A2%98%E6%8A%98%E8%85%BE/image-20191229181102967.png" alt="image-20191229181102967"></p>
<p>添加依赖：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add hexo-wordcount</span><br></pre></td></tr></table></figure>

<p>修改主配置文件，加入一下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># word count setting</span></span><br><span class="line"><span class="comment"># Post wordcount display settings</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/willin/hexo-wordcount</span></span><br><span class="line"><span class="comment"># 文章字数展示设置</span></span><br><span class="line">post_wordcount:</span><br><span class="line">  <span class="comment"># 文本显示</span></span><br><span class="line">  item_text: <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 文章字数统计</span></span><br><span class="line">  wordcount: <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 阅读时长</span></span><br><span class="line">  min2read: <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 站点总字数统计</span></span><br><span class="line">  totalcount: <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 该post_wordcount的所有设置另起一行显示</span></span><br><span class="line">  separated_meta: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h4 id="添加站点地图"><a href="#添加站点地图" class="headerlink" title="添加站点地图"></a>添加站点地图</h4><p>添加依赖</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add hexo-generator-sitemap </span><br><span class="line">yarn add hexo-generator-baidu-sitemap</span><br></pre></td></tr></table></figure>

<p>修改主配置文件加入一下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 自动生成sitemap</span></span><br><span class="line">sitemap:</span><br><span class="line">  path: sitemap.xml</span><br><span class="line">baidusitemap:</span><br><span class="line">  path: baidusitemap.xml</span><br></pre></td></tr></table></figure>

<p>在next主题配置文件中，找到sitemap 并开启</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || home</span><br><span class="line">  categories: /categories/ || th</span><br><span class="line">  tags: /tags/ || tags</span><br><span class="line">  archives: /archives/ || archive</span><br><span class="line">  about: /about/ || user</span><br><span class="line">  books: /books/ || book</span><br><span class="line">  movies: /movies/ || video</span><br><span class="line">  <span class="comment">#schedule: /schedule/ || calendar</span></span><br><span class="line">  sitemap: /sitemap.xml || sitemap</span><br><span class="line">  <span class="comment">#commonweal: /404/ || heartbeat</span></span><br></pre></td></tr></table></figure>

<p>提交百度收录和谷歌收录，具体细节，自行搜索解决，这里就不赘述了。</p>
<h4 id="添加网站运行时间"><a href="#添加网站运行时间" class="headerlink" title="添加网站运行时间"></a>添加网站运行时间</h4><p>在themes\next\layout_partials\footer.swig，添加一下内容，位置可根据情况调整：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!-- 网站运行时间的设置 --&gt;</span><br><span class="line">&lt;span id=<span class="string">"timeDate"</span>&gt;载入天数...&lt;/span&gt;</span><br><span class="line">&lt;span id=<span class="string">"times"</span>&gt;载入时分秒...&lt;/span&gt;  Sometimes your whole life boils down to one insame move.</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var now = new Date();</span><br><span class="line">    <span class="keyword">function</span> <span class="function"><span class="title">createtime</span></span>() &#123;</span><br><span class="line">        var grt= new Date(<span class="string">"03/09/2019 13:14:21"</span>);//此处修改你的建站时间或者网站上线时间</span><br><span class="line">        now.setTime(now.getTime()+250);</span><br><span class="line">        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);</span><br><span class="line">        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);</span><br><span class="line">        <span class="keyword">if</span>(String(hnum).length ==1 )&#123;hnum = <span class="string">"0"</span> + hnum;&#125; minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);</span><br><span class="line">        mnum = Math.floor(minutes); <span class="keyword">if</span>(String(mnum).length ==1 )&#123;mnum = <span class="string">"0"</span> + mnum;&#125;</span><br><span class="line">        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);</span><br><span class="line">        snum = Math.round(seconds); <span class="keyword">if</span>(String(snum).length ==1 )&#123;snum = <span class="string">"0"</span> + snum;&#125;</span><br><span class="line">        document.getElementById(<span class="string">"timeDate"</span>).innerHTML = <span class="string">"本站已安全运行 "</span>+dnum+<span class="string">" 天 "</span>;</span><br><span class="line">        document.getElementById(<span class="string">"times"</span>).innerHTML = hnum + <span class="string">" 小时 "</span> + mnum + <span class="string">" 分 "</span> + snum + <span class="string">" 秒"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">setInterval(<span class="string">"createtime()"</span>,250);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="添加一个炫酷的首页"><a href="#添加一个炫酷的首页" class="headerlink" title="添加一个炫酷的首页"></a>添加一个炫酷的首页</h4><p>未完待续。。。</p>
<h4 id="添加网易云音乐"><a href="#添加网易云音乐" class="headerlink" title="添加网易云音乐"></a><del>添加网易云音乐</del></h4><p><img src="/2019/12/29/Hexo-Next%E4%B8%BB%E9%A2%98%E6%8A%98%E8%85%BE/image-20191230025334681.png" alt="image-20191230025334681"></p>
<p><img src="/2019/12/29/Hexo-Next%E4%B8%BB%E9%A2%98%E6%8A%98%E8%85%BE/image-20191230025408867.png" alt="image-20191230025408867"></p>
<p>这里选择放在侧边栏，所以对应的修改<code>layout\_macro\sidebar.swig</code> 文件</p>
<p><img src="/2019/12/29/Hexo-Next%E4%B8%BB%E9%A2%98%E6%8A%98%E8%85%BE/image-20191230025521725.png" alt="image-20191230025521725"></p>
<p>将代码插入到这个位置，我们就能在side bar上看见我们的音乐播放器了。</p>
<h3 id="添加豆瓣相关页面"><a href="#添加豆瓣相关页面" class="headerlink" title="添加豆瓣相关页面"></a>添加豆瓣相关页面</h3><p>添加依赖： yarn add hexo-douban</p>
<p>配置主_config.yml 文件，添加一下内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">douban:</span><br><span class="line">  user:  <span class="comment"># 个人豆瓣ID</span></span><br><span class="line">  <span class="built_in">builtin</span>: <span class="literal">false</span></span><br><span class="line">  book:</span><br><span class="line">    title: <span class="string">'This is my book title'</span></span><br><span class="line">    quote: <span class="string">'This is my book quote'</span></span><br><span class="line">  movie:</span><br><span class="line">    title: <span class="string">'This is my movie title'</span></span><br><span class="line">    quote: <span class="string">'This is my movie quote'</span></span><br><span class="line">  game:</span><br><span class="line">    title: <span class="string">'This is my game title'</span></span><br><span class="line">    quote: <span class="string">'This is my game quote'</span></span><br><span class="line">  timeout: 10000</span><br></pre></td></tr></table></figure>

<p>user: 填写豆瓣 ID。登陆豆瓣后点击个人主页，此时 url 中最后一段即是用户 ID，一般情况下会是一段数字，如果设置了个人域名的话，则个人域名即为 ID。</p>
<ul>
<li><p>builtin: 是否将生成页面的功能嵌入 <code>hexo s</code> 和 <code>hexo g</code> 中。</p>
</li>
<li><p>timeout: 爬取数据的超时时间。</p>
<p>如果只想生成某一个页面（比如只生成读书页面），把其他的配置项注释掉即可。</p>
</li>
</ul>
<p>在主题配置文件中新增菜单入口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">文件位置:themes\next\_config.yml</span><br><span class="line">menu:</span><br><span class="line">  home: &#x2F; || home</span><br><span class="line">  tags: &#x2F;tags&#x2F; || tags</span><br><span class="line">  categories: &#x2F;categories&#x2F; || th</span><br><span class="line">  archives: &#x2F;archives&#x2F; || archive</span><br><span class="line">  about: &#x2F;about&#x2F; || user</span><br><span class="line">  books: &#x2F;books&#x2F; || book  </span><br><span class="line">  movies: &#x2F;movies&#x2F; || video-camera  </span><br><span class="line">  games: &#x2F;games&#x2F; || gamepad</span><br></pre></td></tr></table></figure>

<p>在语言包中新增菜单中文：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">文件位置:themes\next\language\zh_CN.yml</span><br><span class="line">  menu:</span><br><span class="line">    home: 首页</span><br><span class="line">    archives: 归档</span><br><span class="line">    categories: 分类</span><br><span class="line">    tags: 标签</span><br><span class="line">+   movies: 电影</span><br><span class="line">+   books: 读书</span><br><span class="line">+   games: 游戏</span><br></pre></td></tr></table></figure>

<p>然后在根目录下执行以下命令生成豆瓣阅读 / 电影 / 游戏页面：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo douban</span><br></pre></td></tr></table></figure>

<p>可选参数:</p>
<ul>
<li>-b | –books: 只生成豆瓣读书页面</li>
<li>-m | –movies: 只生成豆瓣电影页面</li>
<li>-g | –games: 只生成豆瓣游戏页面</li>
</ul>
<p>执行命令后，插件会根据用户提供的 ID 爬取豆瓣中的数据信息并在 <code>public</code> 目录下生成对应的页面，当服务器启动或部署后会将页面显示在对应的菜单路由下。</p>
<p>通常大家都喜欢用 hexo d 来作为 hexo deploy 命令的简化，但是当安装了 hexo douban 之后， hexo d 就会有歧义而无法执行，因为 hexo douban 跟 hexo deploy 的 Alias 都是 hexo d。</p>
<h3 id="增加炫酷首页"><a href="#增加炫酷首页" class="headerlink" title="增加炫酷首页"></a>增加炫酷首页</h3><p>目前想给hexo博客添加一个首页没有比较好的方法，基本都是需要在public目录中生成一个index页面，然后将hexo g 自身生产的各种资源增加一层目录。</p>
<p>因为考虑到对博客整体的影响比较大，不利于后面的升级维护，所以就没考虑折腾。这里给出两种方式的连接：</p>
<ol>
<li><a href="https://hexo.52bess.com/diy.html#more" target="_blank" rel="noopener">炫酷的主页</a></li>
<li><a href="https://foradawn.github.io/blog/2018/01/01/Hexo自定义首页/" target="_blank" rel="noopener">Hexo自定义首页</a></li>
</ol>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>还是最开始那句话，折腾这些美化的东西意义不大，最重要的还是博客的内容，这才是关键。</p>
]]></content>
      <categories>
        <category>折腾日记</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title>图片测试</title>
    <url>/2019/12/29/%E5%9B%BE%E7%89%87%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h3 id="这是一个段落"><a href="#这是一个段落" class="headerlink" title="这是一个段落"></a>这是一个段落</h3><p>这是一个测试</p>
]]></content>
      <categories>
        <category>折腾日记</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>Java8 函数式表达式中的异常处理</title>
    <url>/2018/06/14/Java8%20%E5%87%BD%E6%95%B0%E5%BC%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h2 id="1-Overview-概要"><a href="#1-Overview-概要" class="headerlink" title="1. Overview(概要)"></a><strong>1. Overview</strong>(概要)</h2><p>In Java 8, Lambda Expressions started to facilitate functional programming by providing a concise way to express behavior. However, the <em>Functional Interfaces</em> provided by the JDK don’t deal with exceptions very well – and the code becomes verbose and cumbersome when it comes to handling them.</p>
<p>In this article, we’ll explore some ways to deal with exceptions when writing lambda expressions.</p>
<h2 id="2-Handling-Unchecked-Exceptions（处理不可检异常）"><a href="#2-Handling-Unchecked-Exceptions（处理不可检异常）" class="headerlink" title="2. Handling Unchecked Exceptions（处理不可检异常）"></a><strong>2. Handling Unchecked Exceptions</strong>（处理不可检异常）</h2><p>First, let’s understand the problem with an example.</p>
<p>We have a List&lt;Integer&gt; and we want to divide a constant, say 50 with every element of this list and print the results:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; integers &#x3D; Arrays.asList(3, 9, 7, 6, 10, 20);</span><br><span class="line">integers.forEach(i -&gt; System.out.println(50 &#x2F; i));</span><br></pre></td></tr></table></figure>
<p>This expression works but there’s one problem. If any of the elements in the list is 0, then we get an ArithmeticException: / by zero. Let’s fix that by using a traditional try-catch block such that we log any such exception and continue execution for next elements:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; integers &#x3D; Arrays.asList(3, 9, 7, 0, 10, 20);</span><br><span class="line">integers.forEach(i -&gt; &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        System.out.println(50 &#x2F; i);</span><br><span class="line">    &#125; catch (ArithmeticException e) &#123;</span><br><span class="line">        System.err.println(</span><br><span class="line">          &quot;Arithmetic Exception occured : &quot; + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>The use of try-catch solves the problem, but the conciseness of a Lambda Expression is lost and it’s no longer a small function as it’s supposed to be.</p>
<p>To deal with this problem, we can write a lambda wrapper for the lambda function. Let’s look at the code to see how it works:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static Consumer&lt;Integer&gt; lambdaWrapper(Consumer&lt;Integer&gt; consumer) &#123;</span><br><span class="line">    return i -&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            consumer.accept(i);</span><br><span class="line">        &#125; catch (ArithmeticException e) &#123;</span><br><span class="line">            System.err.println(</span><br><span class="line">              &quot;Arithmetic Exception occured : &quot; + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; integers &#x3D; Arrays.asList(3, 9, 7, 0, 10, 20);</span><br><span class="line">integers.forEach(lambdaWrapper(i -&gt; System.out.println(50 &#x2F; i)));</span><br></pre></td></tr></table></figure>
<p>At first, we wrote a wrapper method that will be responsible for handling the exception and then passed the lambda expression as a parameter to this method.</p>
<p>The wrapper method works as expected but, you may argue that it’s basically removing the try-catch block from lambda expression and moving it to another method and it doesn’t reduce the actual number of lines of code being written.</p>
<p>This is true in this case where the wrapper is specific to a particular use case but we can make use of generics to improve this method and use it for a variety of other scenarios:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static &lt;T, E extends Exception&gt; Consumer&lt;T&gt;</span><br><span class="line">  consumerWrapper(Consumer&lt;T&gt; consumer, Class&lt;E&gt; clazz) &#123;</span><br><span class="line">  </span><br><span class="line">    return i -&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            consumer.accept(i);</span><br><span class="line">        &#125; catch (Exception ex) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                E exCast &#x3D; clazz.cast(ex);</span><br><span class="line">                System.err.println(</span><br><span class="line">                  &quot;Exception occured : &quot; + exCast.getMessage());</span><br><span class="line">            &#125; catch (ClassCastException ccEx) &#123;</span><br><span class="line">                throw ex;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; integers &#x3D; Arrays.asList(3, 9, 7, 0, 10, 20);</span><br><span class="line">integers.forEach(</span><br><span class="line">  consumerWrapper(</span><br><span class="line">    i -&gt; System.out.println(50 &#x2F; i), </span><br><span class="line">    ArithmeticException.class));</span><br></pre></td></tr></table></figure>
<p>As we can see, this iteration of our wrapper method takes two arguments, the lambda expression and the type of Exception to be caught. This lambda wrapper is capable of handling all data types, not just Integers, and catch any specific type of exception and not the superclass Exception.</p>
<p>Also, notice that we have changed the name of the method from lambdaWrapper to consumerWrapper. It’s because this method only handles lambda expressions for Functional Interface of type Consumer. We can write similar wrapper methods for other Functional Interfaces like Function, BiFunction, BiConsumer and so on.</p>
<h2 id="3-Handling-Checked-Exceptions（处理可检异常）"><a href="#3-Handling-Checked-Exceptions（处理可检异常）" class="headerlink" title="3. Handling Checked Exceptions（处理可检异常）"></a><strong>3. Handling Checked Exceptions</strong>（处理可检异常）</h2><p>Let’s consider the example from the previous section, but instead of dividing and printing the integers to the console, we want to write them to a file. This operation of writing to a file throws IOException.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static void writeToFile(Integer integer) throws IOException &#123;</span><br><span class="line">    &#x2F;&#x2F; logic to write to file which throws IOException</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; integers &#x3D; Arrays.asList(3, 9, 7, 0, 10, 20);</span><br><span class="line">integers.forEach(i -&gt; writeToFile(i));</span><br></pre></td></tr></table></figure>
<p>On compilation, we get the following error.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java.lang.Error: Unresolved compilation problem: Unhandled exception type IOException</span><br></pre></td></tr></table></figure>
<p>Since IOException is a checked exception, it must be handled. Now there are two options, we may want to throw the exception and handle it somewhere else or handle it inside the method that has the lambda expression. Let’s look at each of them one by one.</p>
<h3 id="3-1-Throwing-Checked-Exception-from-Lambda-Expressions（从函数式表达式中抛出可检异常）"><a href="#3-1-Throwing-Checked-Exception-from-Lambda-Expressions（从函数式表达式中抛出可检异常）" class="headerlink" title="3.1. Throwing Checked Exception from Lambda Expressions（从函数式表达式中抛出可检异常）"></a><strong>3.1. Throwing Checked Exception from Lambda Expressions</strong>（从函数式表达式中抛出可检异常）</h3><p>Let’s throw the exception from the method in which the lambda expression is written, in this case, the main:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) throws IOException &#123;</span><br><span class="line">    List&lt;Integer&gt; integers &#x3D; Arrays.asList(3, 9, 7, 0, 10, 20);</span><br><span class="line">    integers.forEach(i -&gt; writeToFile(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Still, while compiling, we get the same error of unhandled IOException. This is because lambda expressions are similar to Anonymous Inner Classes. In this case, the lambda expression is an implementation of accept(T t) method from Consumer<T> interface.</T></p>
<p>Throwing the exception from main is does nothing and since the method in the parent interface doesn’t throw any exception, it can’t in its implementation:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Consumer&lt;Integer&gt; consumer &#x3D; new Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">  </span><br><span class="line">    @Override</span><br><span class="line">    public void accept(Integer integer) throws Exception &#123;</span><br><span class="line">        writeToFile(integer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>The above code doesn’t compile because the implementation of accept method can’t throw any Exception.</p>
<p>The most straightforward way would be to use a try-catch and wrap the checked exception into an unchecked exception and rethrow:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; integers &#x3D; Arrays.asList(3, 9, 7, 0, 10, 20);</span><br><span class="line">integers.forEach(i -&gt; &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        writeToFile(i);</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        throw new RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>This approach gets the code to compile and run but has the same problem as the example in the case of unchecked exceptions in the previous section.</p>
<p>Since we just want to throw the exception, we need to write our own Consumer Functional Interface which can throw an exception and then a wrapper method using it. Let’s call it ThrowingConsumer:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface ThrowingConsumer&lt;T, E extends Exception&gt; &#123;</span><br><span class="line">    void accept(T t) throws E;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static &lt;T&gt; Consumer&lt;T&gt; throwingConsumerWrapper(</span><br><span class="line">  ThrowingConsumer&lt;T, Exception&gt; throwingConsumer) &#123;</span><br><span class="line">  </span><br><span class="line">    return i -&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            throwingConsumer.accept(i);</span><br><span class="line">        &#125; catch (Exception ex) &#123;</span><br><span class="line">            throw new RuntimeException(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Now we can write our lambda expression which can throw exceptions without losing the conciseness.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; integers &#x3D; Arrays.asList(3, 9, 7, 0, 10, 20);</span><br><span class="line">integers.forEach(throwingConsumerWrapper(i -&gt; writeToFile(i)));</span><br></pre></td></tr></table></figure>

<h3 id="3-2-Handling-a-Checked-Exception-in-Lambda-Expression（在函数式表达式中处理可检异常）"><a href="#3-2-Handling-a-Checked-Exception-in-Lambda-Expression（在函数式表达式中处理可检异常）" class="headerlink" title="3.2. Handling a Checked Exception in Lambda Expression（在函数式表达式中处理可检异常）"></a><strong>3.2. Handling a Checked Exception in Lambda Expression</strong>（在函数式表达式中处理可检异常）</h3><p>In this final section. we will modify the wrapper to handle checked exceptions. Since our ThrowingConsumer interface uses generics, we can handle any specific exception.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static &lt;T, E extends Exception&gt; Consumer&lt;T&gt; handlingConsumerWrapper(</span><br><span class="line">  ThrowingConsumer&lt;T, E&gt; throwingConsumer, Class&lt;E&gt; exceptionClass) &#123;</span><br><span class="line">  </span><br><span class="line">    return i -&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            throwingConsumer.accept(i);</span><br><span class="line">        &#125; catch (Exception ex) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                E exCast &#x3D; exceptionClass.cast(ex);</span><br><span class="line">                System.err.println(</span><br><span class="line">                  &quot;Exception occured : &quot; + exCast.getMessage());</span><br><span class="line">            &#125; catch (ClassCastException ccEx) &#123;</span><br><span class="line">                throw new RuntimeException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We can user this wrapper in our example to handle only the IOException and throw any other checked exception by wrapping them in an unchecked exception:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; integers &#x3D; Arrays.asList(3, 9, 7, 0, 10, 20);</span><br><span class="line">integers.forEach(handlingConsumerWrapper(</span><br><span class="line">  i -&gt; writeToFile(i), IOException.class));</span><br></pre></td></tr></table></figure>
<p>Similar to the case of unchecked exceptions, throwing siblings for other Functional Interfaces like ThowingFunction, ThrowingBiFunction, ThrowingBiConsumer etc. can be written along with their corresponding wrapper methods.</p>
<h2 id="4-Conclusion（总结）"><a href="#4-Conclusion（总结）" class="headerlink" title="4. Conclusion（总结）"></a><strong>4. Conclusion</strong>（总结）</h2><p>In this article, we covered how to handle a specific exception in lambda expressions without losing the conciseness by use of wrapper methods. We also learned how to write throwing alternatives for the Functional Interfaces present in JDK to either throw a checked exception by wrapping them in an unchecked exception or to handle them.</p>
]]></content>
      <categories>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>lambda</tag>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title>巧妙的使用电脑连上wifi</title>
    <url>/2018/04/23/%E5%B7%A7%E5%A6%99%E7%9A%84%E4%BD%BF%E7%94%A8%E7%94%B5%E8%84%91%E8%BF%9E%E4%B8%8Awifi/</url>
    <content><![CDATA[<p>粗看起来，这篇文章的标题是—-巧妙的 使用电脑连上WiFi，这有什么巧妙不巧妙的呢？<br>直接点开电脑的wifi开关，然后找到你想要连接的wifi，输入密码就可以连接了啊！为啥还要大费周章的说是巧妙？</p>
<h3 id="事情是这样的"><a href="#事情是这样的" class="headerlink" title="事情是这样的"></a>事情是这样的</h3><p>出门在外打工，租房的时候免不了要用房东的宽带，不管是有限的还是无线，总之还是得用的。我自己的情况就是，我住的地方，只提供30块钱只能用手机登入的wifi宽带，和60的可以用电脑连接的wifi。作为穷人的我，一下子就怂了，毕竟惹不起。<br>所以就办了一个30的，那么问题就来了，我在宿舍的时候，每次都需要用手机先连接好wifi，然后通过手机中的USB共享宽带给电脑，每次去吃饭，又得拔掉，回来得继续连上。这样就很烦。</p>
<h3 id="有没有解决的方法呢"><a href="#有没有解决的方法呢" class="headerlink" title="有没有解决的方法呢"></a>有没有解决的方法呢</h3><p>之前我是有想到过，是不是他的那个宽带服务是可以察觉到你的设备标识的，如果一旦你是电脑，就提示你不可以在这个上面登入，并且不给你连接wifi的可能。我也找了相关的教程，说该电脑的标识什么的，但是鼓捣一圈下来，并没有什么收获。而且我也怕，设置乱了，有可能以后电脑会出现什么问题。虽然我知道，没有什么是重装系统解决不了的，如果有，那就两次。</p>
<h3 id="突发奇想（其实是我哥发现的）"><a href="#突发奇想（其实是我哥发现的）" class="headerlink" title="突发奇想（其实是我哥发现的）"></a>突发奇想（其实是我哥发现的）</h3><p>宽带是通过网页登录的，也就是说校验的通过与否，是根据这个网页的请求来的，也就是说，对面的宽带系统完全是解析我们在浏览器上发送的 请求来判断的额。联想到以前玩爬虫的时候，可以伪造浏览器的请求头，所以我们可以修改浏览器的请求头来模拟，这个浏览器是移动端的，这样他发送的额请求就是移动设备发出的。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>将wifi打开，然后连接到需要登录的wifi，如果是安装平常的套路，浏览器打开登入的地址，你输入账号密码，他是会提示你不允许在这个平台登入的。然后我们打开chrome浏览器的开发者模式，把显示的窗口换成移动端，然后在输入密码和账号，点击登入，bingo。成功！ 美滋滋，为了防止一不小心刷新，我建议保持这个状态，然后最小化界面，2333！</p>
<p>再也不用连手机啦，爽歪歪！</p>
]]></content>
      <categories>
        <category>杂文随想</category>
      </categories>
      <tags>
        <tag>WiFi</tag>
      </tags>
  </entry>
  <entry>
    <title>在centos7上安装serverSpeeder（锐速）加速你的梯子</title>
    <url>/2018/04/15/install-serverSpeeder-to-centos7/</url>
    <content><![CDATA[<h3 id="为啥要装这个东西？"><a href="#为啥要装这个东西？" class="headerlink" title="为啥要装这个东西？"></a>为啥要装这个东西？</h3><p>serverSpeeder是一个加速网络的软件，在linux和win下都是可以使用的，锐速并不能增加你的带宽，但是可以使你的网络利用率提高，从而增加网络的稳定性和降低访问的失败率。要是我们在已经搭建好的梯子的环境下安装这个锐速，那不是看个YouTube，速度有可见的提高，还不是美滋滋？</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>废话不多说，开始安装。</p>
<ol>
<li><p>首先升级一下你的rpm的软件包吧</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">yum -y update</span><br></pre></td></tr></table></figure></li>
<li><p>是否安装了wget</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y wget</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>获取一键安装脚本<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget -N --no-check-certificate https://raw.githubusercontent.com/wn789/serverspeeder/master/serverspeeder.sh</span><br></pre></td></tr></table></figure></li>
<li>为脚本添加权限并运行改脚本<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod +x serverspeeder.sh</span><br><span class="line">bash serverspeeder.sh</span><br></pre></td></tr></table></figure></li>
<li>检查内核是否支持<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">  在运行4的脚本后，如果出现这样的提示，说明内核不支持，要手动的更换系统的内核</span><br><span class="line">  </span><br><span class="line">  This kernel is not supported. Trying fuzzy matching…</span><br><span class="line">Serverspeeder is not supported on this kernel! View all supported systems and kernels here: https://www.91yun.org/serverspeeder91yun</span><br></pre></td></tr></table></figure>
如果没有，可能会出现叫你选择相近的内核版本：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">  &gt;&gt;&gt;This kernel is not supported. Trying fuzzy matching...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">There is no exact match <span class="keyword">for</span> this kernel, please choose the closest one below:</span><br><span class="line">The current kernel is  3.10.0-123.4.2.el7.x86_64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1：3.10.0-123.x86_64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Please enter the number of your option：</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
说明我们这是有相近的内核版本的，我们选择好就开始安装了。<br>但是在我的vps上，出现了：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">   Installing ServerSpeeder, please <span class="built_in">wait</span> <span class="keyword">for</span> a moment...</span><br><span class="line">./serverspeeder.sh: line 141: ifconfig: <span class="built_in">command</span> not found</span><br><span class="line">./serverspeeder.sh: line 144: ifconfig: <span class="built_in">command</span> not found</span><br><span class="line">The name of network interface is not eth0, please retry after changing the name.</span><br></pre></td></tr></table></figure>
<h3 id="上面是啥问题？"><a href="#上面是啥问题？" class="headerlink" title="上面是啥问题？"></a>上面是啥问题？</h3></li>
</ol>
<ul>
<li><p>我们系统中没有ifconfig这个软件</p>
</li>
<li><p>我们的网卡名字不是eth0，serverspeeder这个软件在安装的时候需要网卡的名字固定为eth0</p>
<h3 id="尝试解决"><a href="#尝试解决" class="headerlink" title="尝试解决"></a>尝试解决</h3></li>
<li><p>在我的vps上使用yum install -y ifconfig，是没办法安装的，提示是没有在软件仓库找到ifconfig,所以google后才知道，这个软件是在net-tools这个套件里面的。  所以我们yum install -y net-tools. </p>
</li>
<li><p>网卡的问题，本来是可以使用ifconfig查看网卡的信息的，但是之前我们还没有解决那个问题，所以我们使用ip addr,   这个命令来查看我们的网卡信息的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> [root@sunrisemenew sunrise]<span class="comment"># ip addr</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: ens3: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000</span><br><span class="line">    link/ether 00:16:3c:9c:89:81 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 0000000 global dynamic ens3</span><br><span class="line">       valid_lft 21599073sec preferred_lft 21599073sec</span><br><span class="line">    inet6 fe80::216:3cff:fe9c:8981/64 scope link</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>
<p>上面的00000是我的服务器ip，这就不写出来了，怕大佬爆破。 可以看到我们的网卡默认是ens3的，这不是我们要的，修改它。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> <span class="built_in">cd</span> /etc/sysconfig/network-scripts/</span><br><span class="line"> </span><br><span class="line"> ifcfg-eth0   ifdown-ippp  ifdown-routes    ifup          ifup-ipv6   ifup-ppp       ifup-tunnel</span><br><span class="line">ifcfg-lo     ifdown-ipv6  ifdown-sit       ifup-aliases  ifup-isdn   ifup-routes    ifup-wireless</span><br><span class="line">ifdown       ifdown-isdn  ifdown-Team      ifup-bnep     ifup-plip   ifup-sit       init.ipv6-global</span><br><span class="line">ifdown-bnep  ifdown-post  ifdown-TeamPort  ifup-eth      ifup-plusb  ifup-Team      network-functions</span><br><span class="line">ifdown-eth   ifdown-ppp   ifdown-tunnel    ifup-ippp     ifup-post   ifup-TeamPort  network-functions-ipv6</span><br><span class="line">[root@sunrisemenew network-scripts]<span class="comment"># cat ifcfg--eth0</span></span><br><span class="line">cat: ifcfg--eth0: No such file or directory</span><br><span class="line">[root@sunrisemenew network-scripts]<span class="comment"># cat ifcfg-eth0</span></span><br><span class="line"><span class="comment"># Generated by SolusVM</span></span><br><span class="line">DEVICE=eth0</span><br><span class="line">BOOTPROTO=static</span><br><span class="line">NAME=eth0 (添加)</span><br><span class="line">HWADDR=xxxxxxxxx(添加)</span><br><span class="line">ONBOOT=yes</span><br><span class="line">IPADDR=000000</span><br><span class="line">GATEWAY=0000000</span><br><span class="line">NETMASK=255.255.255.0[root@sunrisemenew network-scripts]<span class="comment"># cat ifcfg-lo</span></span><br><span class="line">DEVICE=lo</span><br><span class="line">IPADDR=127.0.0.1</span><br><span class="line">NETMASK=255.0.0.0</span><br><span class="line">NETWORK=127.0.0.0</span><br><span class="line"><span class="comment"># If you're having problems with gated making 127.0.0.0/8 a martian,</span></span><br><span class="line"><span class="comment"># you can change this to something else (255.255.255.255, for example)</span></span><br><span class="line">BROADCAST=127.255.255.255</span><br><span class="line">ONBOOT=yes</span><br><span class="line">NAME=loopback</span><br></pre></td></tr></table></figure>
<p>上面我们在我们的网卡脚本里面加了上面的两个项，然后重启服务器。reboot -n 就可以了。</p>
<p>这样我们解决了前面的 两个问题，我们在重新运行安装脚本，./serverspeeder.sh<br>会出现下面的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> --2018-04-15 07:13:40--  http://rs.91yun.pw/CentOS/7.0/3.10.0-123.x86_64/x64/3.10.66.29/serverspeeder_3091</span><br><span class="line">Resolving rs.91yun.pw (rs.91yun.pw)... 104.18.41.84, 104.18.40.84</span><br><span class="line">Connecting to rs.91yun.pw (rs.91yun.pw)|104.18.41.84|:80... connected.</span><br><span class="line">HTTP request sent, awaiting response... 200 OK</span><br><span class="line">Length: 1508272 (1.4M) [application/octet-stream]</span><br><span class="line">Saving to: ‘acce-3.10.66.29-[CentOS_3.10.0-123.x86_64]’</span><br><span class="line"></span><br><span class="line">100%[==============================================================================&gt;] 1,508,272   --.-K/s   <span class="keyword">in</span> 0.1s</span><br><span class="line"></span><br><span class="line">2018-04-15 07:13:40 (9.99 MB/s) - ‘acce-3.10.66.29-[CentOS_3.10.0-123.x86_64]’ saved [1508272/1508272]</span><br><span class="line"></span><br><span class="line">Installation <span class="keyword">done</span>!</span><br><span class="line"></span><br><span class="line">/etc/centos-release:CentOS Linux release 7.4.1708 (Core)</span><br><span class="line">/etc/os-release:NAME=<span class="string">"CentOS Linux"</span></span><br><span class="line">/etc/os-release:PRETTY_NAME=<span class="string">"CentOS Linux 7 (Core)"</span></span><br><span class="line">/etc/os-release:CENTOS_MANTISBT_PROJECT=<span class="string">"CentOS-7"</span></span><br><span class="line">/etc/redhat-release:CentOS Linux release 7.4.1708 (Core)</span><br><span class="line">/etc/system-release:CentOS Linux release 7.4.1708 (Core)</span><br><span class="line">(license 46BFD53099AA52CC113a6b52)</span><br><span class="line"></span><br><span class="line">[Running Status]</span><br><span class="line">ServerSpeeder is running!</span><br><span class="line">version              3.10.66.29</span><br><span class="line"></span><br><span class="line">[License Information]</span><br><span class="line">License              46BFD53099AA52CC (valid on current device)</span><br><span class="line">MaxSession           unlimited</span><br><span class="line">MaxTcpAccSession     unlimited</span><br><span class="line">MaxBandwidth(kbps)   unlimited</span><br><span class="line">ExpireDate           2034-12-31</span><br><span class="line"></span><br><span class="line">[Connection Information]</span><br><span class="line">TotalFlow            1</span><br><span class="line">NumOfTcpFlows        1</span><br><span class="line">TotalAccTcpFlow      0</span><br><span class="line">TotalActiveTcpFlow   0</span><br><span class="line"></span><br><span class="line">[Running Configuration]</span><br><span class="line">accif                eth0</span><br><span class="line">acc                  1</span><br><span class="line">advacc               1</span><br><span class="line">advinacc             1</span><br><span class="line">wankbps              10000000</span><br><span class="line">waninkbps            10000000</span><br><span class="line">csvmode              0</span><br><span class="line">subnetAcc            0</span><br><span class="line">maxmode              1</span><br><span class="line">pcapEnable           0</span><br></pre></td></tr></table></figure>
<p>安装成功。nice，我试了一下，之前vps的速度也就200k，现在可以跑到350k了，还算是可以的，毕竟是乞丐版的配置，也不能要求太多了。</p>
<h3 id="常用的锐速命令"><a href="#常用的锐速命令" class="headerlink" title="常用的锐速命令"></a>常用的锐速命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service serverSpeeder start <span class="comment">#启动</span></span><br><span class="line">service serverSpeeder stop <span class="comment">#停止</span></span><br><span class="line">service serverSpeeder reload <span class="comment">#重新加载配置</span></span><br><span class="line">service serverSpeeder restart <span class="comment">#重启</span></span><br><span class="line">service serverSpeeder status <span class="comment">#状态</span></span><br><span class="line">service serverSpeeder stats <span class="comment">#统计</span></span><br><span class="line">service serverSpeeder renewLic <span class="comment">#更新许可文件</span></span><br><span class="line">service serverSpeeder update <span class="comment">#更新</span></span><br><span class="line">chattr -i /serverspeeder/etc/apx* &amp;&amp; /serverspeeder/bin/serverSpeeder.sh uninstall -f <span class="comment">#卸载</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>shadowsocks</tag>
        <tag>锐速</tag>
        <tag>centos7</tag>
      </tags>
  </entry>
  <entry>
    <title>如何优雅的在win下使用gitbash</title>
    <url>/2018/04/10/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E5%9C%A8win%E4%B8%8B%E4%BD%BF%E7%94%A8gitbash/</url>
    <content><![CDATA[<h2 id="为何我要在win下使用git-bash（优雅的）"><a href="#为何我要在win下使用git-bash（优雅的）" class="headerlink" title="为何我要在win下使用git bash（优雅的）"></a>为何我要在win下使用git bash（优雅的）</h2><p>事情是这样滴，前段时间，xshell（破解版）在我的电脑上就莫名的是用不了，说是服务到期，但是这可是破解版呀（怪不好意思的），当然重装这个软件依然是这样，求救谷歌下载到的依然会出现那个提示，导致我进入不了用户界面。我在xshell上有三台服务器的配置，也就是打开xshell就可以连接这三台服务器了。寻求软件交流群的老铁，给我提供他电脑上安装的版本（免费破解的），我以为差不多就可以，但是这软件就是实在，还是不行。其实也有开源的额免费的ssh客户端，但是由于都不是太好看，没啥设计美学，于是就放弃了。想着，很多人mac大佬都是terminal下ssh连接服务器，我就想，要不就试着在git bash下用ssh连接服务器？</p>
<h2 id="git-bash-ssh连接服务器"><a href="#git-bash-ssh连接服务器" class="headerlink" title="git bash ssh连接服务器"></a>git bash ssh连接服务器</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh username@server_ip</span><br><span class="line"></span><br><span class="line">ssh root@192.168.0.1</span><br><span class="line"></span><br><span class="line">或者是如果你有秘钥文件入xxx.pem</span><br><span class="line">那么接得使用下面的命令</span><br><span class="line"></span><br><span class="line">ssh -i xxx.pem username@server_ip</span><br></pre></td></tr></table></figure>
<p>使用上面的方法确实可以连接到服务器，但是有一下几个缺点：</p>
<ul>
<li>加入你有多个服务器，你就不得不记住这些ip地址，这比较烦</li>
<li>你在输入这些后，你还是要输入登入服务器的密码，非常不方便</li>
<li>要是你切换服务器，你有必须重新输入 </li>
</ul>
<p>那我们如何减轻我们操作的负担呢？</p>
<h2 id="优化一"><a href="#优化一" class="headerlink" title="优化一"></a>优化一</h2><p>为了不再每次ssh登入服务器的时候都要输入密码，我们可以在我们本地生成秘钥，然后在把秘钥推送到服务器上，这样每次我们ssh去连接的时候，就顺带验证了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">首先我们 ssh-keygen 生成我们的秘钥，注意秘钥的保存路径</span><br><span class="line">其次在使用 ssh-copy-id root@server_ip</span><br></pre></td></tr></table></figure>
<p>这样我们ssh登录我们的服务器是不需要输入账户密码的。</p>
<h2 id="优化二"><a href="#优化二" class="headerlink" title="优化二"></a>优化二</h2><p>我们还是得记住ip，这样不好。那有什么办法呢？<br>办法就是我们可以为每个服务器写一个bash的脚本，需要登录的时候，执行这个服务器登录脚本就可以了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -i xxx.pem root@server_ip</span><br><span class="line">或是ssh root@server_ip</span><br></pre></td></tr></table></figure>
<p>我们保存为shortname_server_ip.bash,假设我们有三台服务器，我们分别保存脚本为</p>
<ul>
<li>shortname1.server_ip1.bash</li>
<li>shortname2.server_ip2.bash</li>
<li>shortname3.server_ip3.bash</li>
</ul>
<p>这样我们要登录那个服务器只要，打开gitbash，cd到你放登录脚本的文件夹，然后执行source shortname.server_ip.bash,就可以登录到服务器了，为啥是要这个命令呢？其实使用./shortname.server_ip.bash 也是可以的，但是因为你在win下这样写，他是没有自动补全的(在这种情况下)，那不是我们还得挨个敲，或是ls对照着挨个敲，还是觉得有点麻烦有木有？ source命令呢，就可以弥补这一小点缺陷，所以用用source吧。<br>其实我们还是觉得不够好，因为你必须切换到你防止这些登录脚本的地方，而且每次你还得cd到这个位置，重复的事情做多了就会变得索然无味，对吧。我们要解决他。</p>
<h2 id="优化三"><a href="#优化三" class="headerlink" title="优化三"></a>优化三</h2><p>你会发现有很多bash命令他是全局的，就像ls，cat等，要是我们的脚本可以向他们一样就好了？其实我们的git bash 是有这个功能的，那怎么做呢？</p>
<ul>
<li>我们找到我们的git bash的安装目录，比如我的是 ：C:\Program Files\Git</li>
<li>在这个目录下有一个mingw64的文件夹，你可以将刚才三个登录脚本，放到这个目录的bin目录下面，</li>
<li>修改刚才脚本的后缀名，只保留文件名</li>
<li>最后，在每个脚本的开头 添加上这样一行 #!/bin/sh 也就是linux下指定运行的该文件的程序，然后保存修改。</li>
</ul>
<p>有了这样的修改后我们只要打开 git bash，输入shortname 按tab键就会自动补全我们的脚本名字，我们只需要记住我们的shortname 就可以了。比如我的腾讯云服务器 文件名我就改为 tencent.server_ip 这样有什么需要关于ip的操作我也可以第一时间看到，岂不美滋滋？</p>
<h2 id="想想还可以怎么玩"><a href="#想想还可以怎么玩" class="headerlink" title="想想还可以怎么玩"></a>想想还可以怎么玩</h2><p>大家都应该看过，某些mac或是linux大佬，使用terminal 直接打开某个程序的吧？<br>比如 我需要打开vscode，我就在gitbash中输入 code . ,意思是用vscode打开当前的目录，是不是觉得有点帅？ 这个是因为你在安装的时候vscode 有选项是可以将vscode程序的path，写入到系统环境的变量。<br>大家应该都很熟悉，要是要是一个程序在cmd中可以被识别，那么都可以在环境变量中，将程序的启动文件目录加入到系统的环境变量中去的。但是我们的软件那么多，其实没有必要都加入到系统的环境变量中去。所以按照优化三的方案，其实我们可以以类似的方式实现这样的功能。</p>
<p>但是其实将程序的启动目录加到系统环境变量来实现在bash下启动程序，这里有一个不爽的地方(要是爽，就不会有后面的方案了)，那就是你必须在 命令的后面加上&amp; 使你需要启动的程序进入后台，而不至于被bash阻塞(bash 退出后，你的程序也会退出)。</p>
<h2 id="实现在命令行中打开常用程序"><a href="#实现在命令行中打开常用程序" class="headerlink" title="实现在命令行中打开常用程序"></a>实现在命令行中打开常用程序</h2><ul>
<li>在我们的git bash安装目录下，找到mingw64下的bin文件夹，加入我们想设置的程序。</li>
<li>假设我想在bash下使用idea编辑器，在git clone 别人仓库的时候，进入到仓库，直接idea .,打开整个项目，岂不美哉？</li>
<li>我们在bin文件夹下建立一个叫idea的文件，无后缀。</li>
<li>在开头写上<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="string">"C:\Program Files\JetBrains\IntelliJ IDEA 2018.1\bin\idea64.exe"</span> <span class="variable">$1</span> &amp;</span><br></pre></td></tr></table></figure></li>
<li>保存(上面只是我电脑环境的，你可以按照自己的需求来写，就是填程序启动具体是哪一个启动的)</li>
</ul>
<p>这样你就可以在打开git bash的时候在上面敲 idea . 就会在当前目录启动你的成程序啦！</p>
]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>git</tag>
        <tag>gitbash</tag>
      </tags>
  </entry>
  <entry>
    <title>有return的情况下try catch finally的执行顺序</title>
    <url>/2017/09/28/%E6%9C%89return%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8Btry%20catch%20finally%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/</url>
    <content><![CDATA[<p>题目：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int getNumber() &#123;</span><br><span class="line">       int a &#x3D; 0;</span><br><span class="line">       try &#123;</span><br><span class="line">           String s &#x3D; &quot;t&quot;; ------------------------（1）</span><br><span class="line">           a &#x3D; Integer.parseInt(s);-----------（2）</span><br><span class="line">           return a;</span><br><span class="line">       &#125; catch (NumberFormatException e) &#123;</span><br><span class="line">           a &#x3D; 1;-----------------------------------（3）</span><br><span class="line">           return a;-------------------------------（4）</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           a &#x3D; 2;-----------------------------------（5）</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>结果是返回多少呢？返回值为1.<br>归为这样的执行顺序：<br>先执行try或catch里里面的代码，然后再执行finally，再执行try或catch里面的return.</p>
<p>结论：</p>
<pre><code>不管有木有出现异常，finally块中代码都会执行；
当try和catch中有return时，finally仍然会执行；
finally是在return后面的表达式运算后执行的（此时并没有返回运算后的值，而是先把要返回的值保存起来，管finally中的代码怎么样，返回的值都不会改变，任然是之前保存的值），所以函数返回值是在finally执行前确定的；
finally中最好不要包含return，否则程序会提前退出，返回值不是try或catch中保存的返回值。</code></pre><p>举例：<br>情况1：try{} catch(){}finally{} return;<br>显然程序按顺序执行。</p>
<p>情况2:try{ return; }catch(){} finally{} return;<br>程序执行try块中return之前（包括return语句中的表达式运算）代码；再执行finally块，最后执行try中return;finally块之后的语句return，因为程序在try中已经return所以不再执行。</p>
<p>情况3:try{ } catch(){return;} finally{} return;<br>程序先执行try，如果遇到异常执行catch块，<br>有异常：则执行catch中return之前（包括return语句中的表达式运算）代码，再执行finally语句中全部代码，最后执行catch块中return. finally之后也就是4处的代码不再执行。无异常：执行完try再finally再return.</p>
<p>情况4:try{ return; }catch(){} finally{return;}<br>程序执行try块中return之前（包括return语句中的表达式运算）代码；再执行finally块，因为finally块中有return所以提前退出。</p>
<p>情况5:try{} catch(){return;}finally{return;}<br>程序执行catch块中return之前（包括return语句中的表达式运算）代码；再执行finally块，因为finally块中有return所以提前退出。</p>
<p>情况6:try{ return;}catch(){return;} finally{return;}<br>程序执行try块中return之前（包括return语句中的表达式运算）代码；有异常：执行catch块中return之前（包括return语句中的表达式运算）代码；则再执行finally块，因为finally块中有return所以提前退出。无异常：则再执行finally块，因为finally块中有return所以提前退出。</p>
<p>最终结论：任何执行try 或者catch中的return语句之前，都会先执行finally语句，如果finally存在的话。如果finally中有return语句，那么程序就return了，所以finally中的return是一定会被return的，编译器把finally中的return实现为一个warning。</p>
<p>下面是个测试程序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class FinallyTest  </span><br><span class="line">&#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		 </span><br><span class="line">		System.out.println(new FinallyTest().test());;</span><br><span class="line">	&#125;</span><br><span class="line">	static int test()</span><br><span class="line">	&#123;</span><br><span class="line">		int x &#x3D; 1;</span><br><span class="line">		try</span><br><span class="line">		&#123;</span><br><span class="line">			x++;</span><br><span class="line">			return x;</span><br><span class="line">		&#125;</span><br><span class="line">		finally</span><br><span class="line">		&#123;</span><br><span class="line">			++x;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果是2。</p>
<p>分析：</p>
<p>在try语句中，在执行return语句时，要返回的结果已经准备好了，就在此时，程序转到finally执行了。<br>在转去之前，try中先把要返回的结果存放到不同于x的局部变量中去，执行完finally之后，在从中取出返回结果，<br>因此，即使finally中对变量x进行了改变，但是不会影响返回结果。它应该使用栈保存返回值。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>201709Java面试题目总结</title>
    <url>/2017/09/26/201709Java%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93%20/</url>
    <content><![CDATA[<p>碰到的Java笔试题</p>
<ol>
<li>下面正确的是（B）<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> public class A &#123;  </span><br><span class="line"> public void start() &#123;  </span><br><span class="line">  System.out.println(&quot;TestA&quot;); </span><br><span class="line"> &#125; </span><br><span class="line">&#125;  </span><br><span class="line">public class B extends A &#123; </span><br><span class="line"> public void start() &#123;  </span><br><span class="line">  System.out.println(&quot;TestB&quot;); </span><br><span class="line"> &#125;  </span><br><span class="line"> public static void main(String[] args) &#123; </span><br><span class="line">  ( (A) new B( ) ).start(); </span><br><span class="line"> &#125; </span><br><span class="line">&#125;  </span><br><span class="line"> A.输出：TestA </span><br><span class="line"> B.输出：TestB </span><br><span class="line"> C.输出：TestA  TestB </span><br><span class="line"> D.编译错误</span><br></pre></td></tr></table></figure></li>
<li>下面正确的是(D)<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> interface DeclareStuff &#123;</span><br><span class="line"> public static final int EASY &#x3D; 3;</span><br><span class="line"> void doStuff(int t); &#125;. public class TestDeclare implements DeclareStuff &#123;</span><br><span class="line"> public static void main(String [] args) &#123;</span><br><span class="line"> int x &#x3D; 5;</span><br><span class="line"> new TestDeclare().doStuff(++x);</span><br><span class="line"> &#125;</span><br><span class="line"> void doStuff(int s) &#123;</span><br><span class="line">s +&#x3D; EASY + ++s;</span><br><span class="line"> System.out.println(&quot;s &quot; + s);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">结果为何?</span><br><span class="line">A. s 14</span><br><span class="line">B. s 16</span><br><span class="line">C. s 10</span><br><span class="line">D. 编译失败。</span><br><span class="line">E. 执行阶段丢出异常。</span><br><span class="line">Answer: D</span><br><span class="line">解析：被实现的接口必须声明为public，否则编译错误。</span><br></pre></td></tr></table></figure></li>
<li>说出String，StringBuffer和StringBuilder的区别和相同之处。</li>
</ol>
<p>答：1.可变与不可变<br>　　String类中使用字符数组保存字符串，如下就是，因为有“final”修饰符，所以可以知道string对象是不可变的。<br>　　　　private final char value[];<br>　　StringBuilder与StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串，如下就是，可知这两种对象都是可变的。<br>　　　　char[] value;<br>2.是否多线程安全<br>　　String中的对象是不可变的，也就可以理解为常量，显然线程安全。<br>　　AbstractStringBuilder是StringBuilder与StringBuffer的公共父类，定义了一些字符串的基本操作，如expandCapacity、append、insert、indexOf等公共方法。<br>　　StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。看如下源码： 　　</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public synchronized StringBuffer reverse() &#123;</span><br><span class="line">     super.reverse();</span><br><span class="line">     return this;</span><br><span class="line"> &#125;</span><br><span class="line"> public int indexOf(String str) &#123;</span><br><span class="line">     return indexOf(str, 0);        &#x2F;&#x2F;存在 public synchronized int indexOf(String str, int fromIndex) 方法</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>　　StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。<br>3.StringBuilder与StringBuffer共同点<br>　　StringBuilder与StringBuffer有公共父类AbstractStringBuilder(抽象类)。<br>　　抽象类与接口的其中一个区别是：抽象类中可以定义一些子类的公共方法，子类只需要增加新的功能，不需要重复写已经存在的方法；而接口中只是对方法的申明和常量的定义。<br>　　StringBuilder、StringBuffer的方法都会调用AbstractStringBuilder中的公共方法，如super.append(…)。只是StringBuffer会在方法上加synchronized关键字，进行同步。<br>　　最后，如果程序不是多线程的，那么使用StringBuilder效率高于StringBuffer。<br>4. HashMap和HashTable区别，初始化大小和相同</p>
<p>答：1. 存储方式相同，利用一个内部类，实现的是Map.Entity接口，但内部实现不同，但是都是以节点的方式进行存储。是一种单向链表，链表是基于数组的。都是通过hashcode找到数组中的某一元素，然后通过key的equals方法在链表中找到key对应的value。</p>
<ol start="2">
<li>HashMap可以允许key为null，value为null。但HashTable都不允许为null。（为什么HashMap中的key可以为null呢？</li>
</ol>
<p>　　这是因为HashMap和HashTable它们计算一个对象的hashCode时的方法不一样。HashMap不是直接用对象自己的hashCode，而是自己重新计算一下hashCode，而HashTable直接用对象本上的hashCode，</p>
<p>并没有再进行计算。这个地方HashMap会稍慢一点HashTable。）<br>3.继承的类不一样：</p>
<p> 继承的类不一样<br>public class Hashtable&lt;K,V&gt; extends Dictionary&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, java.io.Serializable<br>public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable</p>
<p>Hashtable继承的是Dictionary，而HashMap继承的是AbstractMap。<br>4.同步机制不一样</p>
<p>　　HashMap没有提供同步机制，是线程不安全的，需要自己在外面写同步代码，HashTable 部分方法上有自己的 synchronize 同步，是线程安全的。由于HashMap是线程不安全的，所以效率可能会高一点，而且在类外面控制线程安全更灵活。<br>5.HashMap中没有contains（）方法。</p>
<p>6.它们的数组初始化大小和扩容方式不一样，HashTable中hash数组默认大小是11，增加的方式是 old*2+1。HashMap中hash数组的默认大小是16，而且一定是2的指数。<br>5. ArrayList和LinkedList的区别，初始化大小，相同之处</p>
<p>相同之处：都实现了java.lang.List接口，都是非线程安全的。<br>区别：</p>
<pre><code>ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。
对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。
对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。
每一个ArrayList都有一个初始容量（10），该容量代表了数组的大小。随着容器中的元素不断增加，容器的大小也会随着增加。在每次向容器中增加元素的同时都会进行容量检查，当快溢出时，就会进行扩容操作。所以如果我们明确所插入元素的多少，最好指定一个初始容量值，避免过多的进行扩容操作而浪费时间、效率。
6. 描述线程的生命周期以及线程每个状态的解释和作用？
线程的生命周期:
线程是一个动态执行的过程，它也有一个从产生到死亡的过程。</code></pre><p>(1)生命周期的五种状态</p>
<p>新建（new Thread）<br>当创建Thread类的一个实例（对象）时，此线程进入新建状态（未被启动）。<br>例如：Thread t1=new Thread();</p>
<p>就绪（runnable）<br>线程已经被启动，正在等待被分配给CPU时间片，也就是说此时线程正在就绪队列中排队等候得到CPU资源。例如：t1.start();</p>
<p>运行（running）<br>线程获得CPU资源正在执行任务（run()方法），此时除非此线程自动放弃CPU资源或者有优先级更高的线程进入，线程将一直运行到结束。</p>
<p>死亡（dead）<br>当线程执行完毕或被其它线程杀死，线程就进入死亡状态，这时线程不可能再进入就绪状态等待执行。</p>
<p>自然终止：正常运行run()方法后终止</p>
<p>异常终止：调用stop()方法让一个线程终止运行</p>
<p>堵塞（blocked）<br>由于某种原因导致正在运行的线程让出CPU并暂停自己的执行，即进入堵塞状态。</p>
<p>正在睡眠：用sleep(long t) 方法可使线程进入睡眠方式。一个睡眠着的线程在指定的时间过去可进入就绪状态。</p>
<p>正在等待：调用wait()方法。（调用motify()方法回到就绪状态）</p>
<p>被另一个线程所阻塞：调用suspend()方法。（调用resume()方法恢复）</p>
<p>下图是它所对应的5种基本状态：</p>
<p>一个线程应该在创建状态完成之后，进入就绪状态，代表着它已经准备好了，只需要等待CPU的资源，但是等待的时间是不确定的，这个时间段有可能会进入阻塞状态，线程会在阻塞状态与运行状态直接进行切换，最后直到run方法执行完毕，整个线程也就结束了；阻塞状态有几种情形，一种是线程</p>
<p>正在睡眠：用sleep(long t) 方法可使线程进入睡眠方式。一个睡眠着的线程在指定的时间过去可进入就绪状态。</p>
<p>正在等待：调用wait()方法。（调用motify()方法回到就绪状态）</p>
<p>被另一个线程所阻塞：调用suspend()方法。（调用resume()方法恢复）</p>
<p>前面两种阻塞状态都是可以控制的，而最后一种阻塞状态就有点危险了，万一遇到死锁就很糟糕了。我们可以更改一下线程的优先级，线程有三种优先级</p>
<p>static int MAX_PRIORITY<br>线程可以具有的最高优先级。<br>static int MIN_PRIORITY<br>线程可以具有的最低优先级。<br>static int NORM_PRIORITY<br>分配给线程的默认优先级。</p>
<p>或者使用Thread.yield()方法作用是：暂停当前正在执行的线程对象，并执行其他线程。也可以使用join,join()的作用是：“等待该线程终止”，这里需要理解的就是该线程是指的主线程等待子线程的终止。也就是在子线程调用了join()方法后面的代码，只有等到子线程结束了才能执行。</p>
<p>流程分析：</p>
<p>首先是通过new Thread（）方法实例化一个新线程，然后改线程的对象调用start()方法，此时线程转入到就绪状态并且等待cpu的调度，可能不是马上就调度到此线程的，这和cpu的轮询策略有关，例如时间片轮询策略。<br>    线程运行，执行run方法，如果中途没被其他操作线程的方法操作的话，那么run方法运行完毕，线程死亡。<br>     如果在线程run的过程中，执行了别的操作线程的方法，如果有调用sleep方法的线程，改线程会暂停一段时间，而且不会释放资源锁，，也就是说如果有synchronized同步块，其它线程仍然是不能访问共享数据的。而且sleep方法给其它的线程运行的机会，而且是不考虑其它线程的优先级的。当前线程转入睡眠状态，直到睡眠结束。如果当前线程调用的是其它线程的join方法，当前的进程状态将转入到挂起状态，知道另外一线程运行结束，该线程才继续运行。当当前线程是等待IO输入，则当前线程进入等待状态，知道输入流结束。<br>     如果当前线程执行了yeild方法，当前线程进入到就绪状态，并让出cpu的控制权，cpu执行别的线程。<br>     如果在run方法中，当前线程执行了wait（）方法，使当前线程暂停，当前线程进入等待状态，在其他线程调用此对象的 notify() 方法或者 notifyAll()方法，该线程进入阻塞状态，因为是在同步块中进行的，所以要等待当前资源释放资源，然后进入解锁，到就绪状态。<br>    如果是线程加了同步锁的话，该线程对资源独享，其它线程想操作此数据，将进入到阻塞状态，知道同步锁的线程操作完资源，进行解锁，从而转入到就绪状态。</p>
<p>7.画出springMVC的流程图</p>
<p>1.先用文字描述</p>
<pre><code>用户向服务器发送请求，请求被Spring 前端控制Servelt DispatcherServlet捕获；
DispatcherServlet对请求URL进行解析，得到请求资源标识符（URI）。然后根据该URI，调用HandlerMapping获得该Handler配置的所有相关的对象（包括Handler对象以及Handler对象对应的拦截器），最后以HandlerExecutionChain对象的形式返回；
DispatcherServlet 根据获得的Handler，选择一个合适的HandlerAdapter。（附注：如果成功获得HandlerAdapter后，此时将开始执行拦截器的preHandler(…)方法）
提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)。 在填充Handler的入参过程中，根据你的配置，Spring将帮你做一些额外的工作：
HttpMessageConveter： 将请求消息（如Json、xml等数据）转换成一个对象，将对象转换为指定的响应信息
数据转换：对请求消息进行数据转换。如String转换成Integer、Double等
数据根式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等
数据验证： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中
Handler执行完成后，向DispatcherServlet 返回一个ModelAndView对象；
根据返回的ModelAndView，选择一个适合的ViewResolver（必须是已经注册到Spring容器中的ViewResolver)返回给DispatcherServlet ；
ViewResolver 结合Model和View，来渲染视图
将渲染结果返回给客户端。
流程图：![enter description here][1]</code></pre><p>8.请求的转发与重定向的区别</p>
<p>深入（分析理解）</p>
<p>转发过程<br>客户首先发送一个请求到服务器端，服务器端发现匹配的servlet，并指定它去执行，当这个servlet执行完之后，它要调用getRequestDispacther()方法，把请求转发给指定的student_list.jsp,整个流程都是在服务器端完成的，而且是在同一个请求里面完成的，因此servlet和jsp共享的是同一个request，在servlet里面放的所有东西，在student_list中都能取出来，因此，student_list能把结果getAttribute()出来，getAttribute()出来后执行完把结果返回给客户端。整个过程是一个请求，一个响应。</p>
<p>重定向过程<br>客户发送一个请求到服务器，服务器匹配servlet，这都和请求转发一样，servlet处理完之后调用了sendRedirect()这个方法，这个方法是response的方法，所以，当这个servlet处理完之后，看到response.senRedirect()方法，立即向客户端返回这个响应，响应行告诉客户端你必须要再发送一个请求，去访问student_list.jsp，紧接着客户端受到这个请求后，立刻发出一个新的请求，去请求student_list.jsp,这里两个请求互不干扰，相互独立，在前面request里面setAttribute()的任何东西，在后面的request里面都获得不了。可见，在sendRedirect()里面是两个请求，两个响应。</p>
<p>浅出（表象）<br>转发<br>当用RequestDispatcher请求转发后，地址栏为<a href="http://localhost:8080/test/TestServlet" target="_blank" rel="noopener">http://localhost:8080/test/TestServlet</a><br>这真好应正了上面的分析，我们起初请求的就一个servlet，至于你服务器端怎么转，流程怎么样的，我客户端根本就不知道，我发了请求后我就等着响应，那你服务器那边愿意怎么转就怎么转，我客户端不关心也没法知道，所以当服务器端转发到jsp后，它把结果返回给客户端，客户端根本就不知道你这个结果是我真正访问的servlet产生的，还是由servlet转发后下一个组件产生的。</p>
<p>重定向<br>当用sendRedirect重定向后，地址栏为<a href="http://localhost:8080/test/student_list.jsp" target="_blank" rel="noopener">http://localhost:8080/test/student_list.jsp</a><br>因为这个时候，客户端已经知道了他第二次请求的是student_list.jsp，服务器已经告诉客户端要去访问student_list.jsp了，所以地址栏里会显示想要访问的结果。</p>
<p>总结<br>转发在服务器端完成的；重定向是在客户端完成的<br>转发的速度快；重定向速度慢<br>转发的是同一次请求；重定向是两次不同请求<br>转发不会执行转发后的代码；重定向会执行重定向之后的代码<br>转发地址栏没有变化；重定向地址栏有变化<br>转发必须是在同一台服务器下完成；重定向可以在不同的服务器下完成</p>
<p>Forward是在服务器端的跳转，就是客户端一个请求发给服务器，服务器直接将请求相关的参数的信息原封不动的传递到该服务器的其他jsp或servlet去处理，而sendredirect是在客户端的跳转，服务器会返回给客户端一个响应报头和新的URL地址，原来的参数什么的信息如果服务器端没有特别处理就不存在了，浏览器会访问新的URL所指向的servlet或jsp，这可能不是原先服务器上的webservce了。<br>9.JSP页面一共有多少个隐含对象,分别对应java的哪些类</p>
<p>1、out 来源于java.io.Writer类，它用于发送输出流到客户端。<br>2、request 来源于javax.servlet.http.HttpServletRequest接口。它被关联到每一个HTTP请求。<br>3、response 来源于javax.servlet.http.HttpServletResponse。response对象用于把取得的数据返回到客户端。<br>4、pageContext 提供访问JSP页面的命名空间。它也提供用来访问其他的JSP隐含对象。<br>5、session 来源于javax.servlet.http.HttpSession。它用于存储客户端请求的信息，因此它是有状态交互式的。<br>6、application 来源于javax.servlet.ServletContext。<br>7、config 来源于ServletConfig，它包含了当前JSP/Servlet所在的WEB应用的配置信息。<br>8、page 来源于当前被访问JSP页面的实例化。它实际使用的是JSP转换成的Servlet。<br>9、exception 用于捕获JSP抛出的异常。它只有在JSP页面属性isErrorPage=true时才可用。<br>10.怎样解决表单重复提交问题</p>
<p>1.js方法解决:关于js方法解决就是说通过js动态控制提交按钮不能多次点击，或者多次点击不起作用。<br>2.设置HTTP报头，控制表单缓存，使得所控制的表单不缓存信息，这样用户就无法通过重复点击按钮去重复提交表单。<br>3.通过PRG设计模式(用来防止F5刷新重复提交表单)<br>4.如果是注册或存入数据库的操作，可以通过在数据库中字段设立唯一标识来解决，这样在进行数据库插入操作时，因为每次插入的数据都相同，数据库会拒绝写入。这样也避免了向数据库中写入垃圾数据的情况，同时也解决了表单重复提交问题。<br>5.session方法:<br>在struts框架中防止表单重复提交的方法是生成Token存入session，以此判断表单是否是第一次提交<br>11.Java Web如何解决中文乱码问题 ：</p>
<p>方法一：<br>tomcat的自带编码是ISO-8859-1的格式，是不兼容中文的编码的。所以我们从后台接收的时候要注意。<br>采用相同的格式去接收（ISO-8859-1)，然后用能解析的编码(utf-8)去转换。这样我们就能得到能兼容中文的格式了。这样处理之后发往前台。注意：发往前台的时候也需要设置一下<br>resp.setContentType(“text/html;charset=utf-8”);//设置页面的字符编码，解决界面显示中文乱码的问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected void service(HttpServletRequest req, HttpServletResponse resp)</span><br><span class="line">throws ServletException, IOException &#123;</span><br><span class="line">&#x2F;&#x2F;因为tomcat自带编码是ISO-8859-1格式</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;解决乱码方法之一</span><br><span class="line">  String name&#x3D;req.getParameter(“username”);</span><br><span class="line">  String pwd&#x3D;req.getParameter(“pwd”);</span><br><span class="line">  byte[] b&#x3D;name.getBytes(“ISO-8859-1”);&#x2F;&#x2F;用tomcat的格式（iso-8859-1）方式去读。</span><br><span class="line">  String str&#x3D;new String(b,”utf-8”);&#x2F;&#x2F;采用utf-8去接string</span><br><span class="line">  resp.setContentType(“text&#x2F;html;charset&#x3D;utf-8”);&#x2F;&#x2F;设置页面的字符编码 </span><br><span class="line"></span><br><span class="line">  PrintWriter pw &#x3D;resp.getWriter();</span><br><span class="line">  String str1&#x3D;”username:”+name+”pwd:”+pwd+”“;</span><br><span class="line">  pw.print(str1);</span><br><span class="line">PrintWriter pw &#x3D;resp.getWriter();</span><br><span class="line">String str1&#x3D;”username:”+name+”pwd:”+pwd+”“;</span><br><span class="line">pw.print(str1);</span><br></pre></td></tr></table></figure>
<p>方法二：<br>由于方法一比较繁琐，采用用了简单的设置。只需要简单的一句就可以搞定<br>req.setCharacterEncoding(“utf-8”);//必须写在第一位，因为采用这种方式去读取数据，否则数据会出错。<br>这样就不用像之前的那样繁琐的设置了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected void service(HttpServletRequest req, HttpServletResponse resp)</span><br><span class="line">throws ServletException, IOException &#123;</span><br><span class="line">&#x2F;&#x2F;因为tomcat自带编码是ISO-8859-1格式</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;解决乱码二《法一比较繁琐》</span><br><span class="line">req.setCharacterEncoding(“utf-8”);&#x2F;&#x2F;必须写在第一位，因为采用这种方式去读取数据，否</span><br><span class="line"></span><br><span class="line">则数据会出错。</span><br><span class="line">&#x2F;&#x2F;设置这样方式去读。这样中文就能够读取出来了，但是需要注意。表单的发送方式必须是 method&#x3D;’post’</span><br><span class="line">resp.setContentType(“text&#x2F;html;charset&#x3D;utf-8”);&#x2F;&#x2F;设置传过去的页面显示的编码</span><br><span class="line">String name&#x3D;req.getParameter(“username”);</span><br><span class="line">String pwd&#x3D;req.getParameter(“pwd”);</span><br><span class="line">PrintWriter pw &#x3D;resp.getWriter();</span><br><span class="line">String str1&#x3D;”username:”+name+”pwd:”+pwd+”“;</span><br><span class="line">pw.print(str1);</span><br></pre></td></tr></table></figure>
<p>方法三：</p>
<p>这是在法二的基础上修改的。虽然我们能修改编码格式去读，但是考虑到用户肯定不会修改，所以我们需要采用比较通用的办法，让用户修改配置文件。也就是web.xml文件<br>需要修改web.xml里面的内容，就是说，字符编码从xml接收过来。需要在xml文件中配置参数。<br>代码如下：</p>
<p>Encodeing<br>cn.hncu.com.encode.Encodeing</p>
<p>charset<br>utf-8//这里面的内容可供用户自己填写（必须是编码格式）</p>
<p>我们知道前台和后台进行交换必须经过web.xml配置<br>我们需要获取web.xml的设置的参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void init(ServletConfig config) throws ServletException &#123;</span><br><span class="line">charset&#x3D;config.getInitParameter(“charset”);&#x2F;&#x2F;获得初始化参数。当然charset需要设置为全局变量。后面的service函数需要设置req.setCharacterEncoding(charset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">req.setCharacterEncoding(charset);</span><br><span class="line">resp.setContentType(“text&#x2F;html;charset&#x3D;utf-8”);</span><br><span class="line">String name&#x3D;req.getParameter(“username”);</span><br><span class="line">String pwd&#x3D;req.getParameter(“pwd”);</span><br><span class="line"></span><br><span class="line">PrintWriter pw &#x3D;resp.getWriter();</span><br><span class="line">String str1&#x3D;”username:”+name+”pwd:”+pwd+”“;</span><br><span class="line">pw.print(str1);</span><br></pre></td></tr></table></figure>
<p>解决的效果图：</p>
<p>解决之前：</p>
<p>解决之后：</p>
<p>前台代码：</p>
<body> 
 <form action="login" method="post">//login在web.xml中配置，就能实现到后台去读取数据 
 用户名：<input type="text" name="username"><br> 
 密码：<input type="password" name="pwd"><br> 
 <input type="submit" value="登录"> 
 </form> 
 <script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/assets/koharu.model.json"},"display":{"width":200,"height":350,"position":"right","hOffset":-10,"vOffset":-50},"mobile":{"show":true,"scale":0.35},"log":false,"tagMode":false});</script></body>

<p>12.HashMap数据结构及实现原理，其链表是用来解决什么问题的？</p>
<p>暂时比较难回答。</p>
<p>###13.冒泡排序算法<br>14.阐述你对get post的理解，写出它们的一般使用场景</p>
<p>GET和POST两种方法都是将数据送到服务器。HTTP标准包含这两种方法是为了达到不同的目的。</p>
<p>POST用于创建资源，资源的内容会被编入HTTP请示的内容中。例如，处理订货表单、在数据库中加入新数据行等。<br>当请求无副作用时（如进行搜索），便可使用GET方法；当请求有副作用时（如添加数据行），则用POST方法。一个比较实际的问题是：GET方法可能会产生很长的URL，或许会超过某些浏览器与服务器对URL长度的限制。</p>
<p>若符合下列任一情况，则用POST方法：</p>
<pre><code>请求的结果有持续性的副作用，例如，数据库内添加新的数据行。
若使用GET方法，则表单上收集的数据可能让URL过长。
要传送的数据不是采用7位的ASCII编码。</code></pre><p>若符合下列任一情况，则用GET方法：</p>
<pre><code>请求是为了查找资源，HTML表单数据仅用来帮助搜索。

请求结果无持续性的副作用。

收集的数据及HTML表单内的输入字段名称的总长不超过1024个字符。</code></pre><p>HTTP 定义了与服务器交互的不同方法，最常用的有4种，Get、Post、Put、Delete,如果我换一下顺序就好记了，Put（增）,Delete（删），Post（改）,Get（查），即增删改查，下面简单叙述一下：</p>
<p>1）Get， 它用于获取信息，注意，他只是获取、查询数据，也就是说它不会修改服务器上的数据，从这点来讲，它是数据安全的，而稍后会提到的Post它是可以修改数据的，所以这也是两者差别之一了。</p>
<p>2） Post，它是可以向服务器发送修改请求，从而修改服务器的，比方说，我们要在论坛上回贴、在博客上评论，这就要用到Post了，当然它也是可以仅仅获取数据的。</p>
<p>3）Delete 删除数据。可以通过Get/Post来实现。用的不多，暂不多写，以后扩充。</p>
<p>4）Put，增加、放置数据，可以通过Get/Post来实现。用的不多，暂不多写，以后扩充。</p>
<p>下面简述一下Get和Post区别：</p>
<p>1） GET请求的数据是放在HTTP包头中的，也就是URL之后，通常是像下面这样定义格式的，（而Post是把提交的数据放在HTTP正文中的）。</p>
<p>login.action?name=hyddd&amp;password=idontknow&amp;verify=%E4%BD%E5%A5%BD</p>
<p>a，以 ？ 来分隔URL和数据；<br>b，以&amp; 来分隔参数；<br>c，如果数据是英文或数字，原样发送；<br>d，如果数据是中文或其它字符，则进行BASE64编码。<br>2）GET提交的数据比较少，最多1024B，因为GET数据是附在URL之后的，而URL则会受到不同环境的限制的，比如说IE对其限制为2K+35，而POST可以传送更多的数据（理论上是没有限制的，但一般也会受不同的环境，如浏览器、操作系统、服务器处理能力等限制，IIS4可支持80KB，IIS5可支持100KB）。<br>3）Post的安全性要比Get高，因为Get时，参数数据是明文传输的，而且使用GET的话，还可能造成Cross-site request forgery攻击。而POST数据则可以加密的，但GET的速度可能会快些。<br>所以综上几点，总结成下表：<br>操作方式 数据位置 明文密文 数据安全 长度限制 应用场景</p>
<p>GET HTTP包头 明文 不安全 长度较小 查询数据</p>
<p>POST HTTP正文 可明可密 安全 支持较大数据传输 修改数据<br>总的来说，get是用来查询数据，post是用来修改数据。比方说，我们要在论坛上回贴、在博客上评论，这就要用到Post了，当然它也是可以仅仅获取数据的。<br>15.简述tcp建立连接的三次握手，断开连接的四次握手的具体过程</p>
<p>TCP的三次握手和四次断开<br>TCP是一个面向连接的服务,面向连接的服务是电话系统服务模式的抽象,每一次完整的数据传输都必须经过建<br>立连接,数据传输和终止连接3个过程,TCP建立连接的过程称为三次握手,下面看一下三次握手的具本过程<br>TCP三次握手过程<br>1 主机A通过向主机B 发送一个含有同步序列号的标志位的数据段给主机B ,向主机B 请求建立连接,通过这个数据段,<br>主机A告诉主机B 两件事:我想要和你通信;你可以用哪个序列号作为起始数据段来回应我.<br>2 主机B 收到主机A的请求后,用一个带有确认应答(ACK)和同步序列号(SYN)标志位的数据段响应主机A,也告诉主机A两件事:<br>我已经收到你的请求了,你可以传输数据了;你要用哪个序列号作为起始数据段来回应我<br>3 主机A收到这个数据段后,再发送一个确认应答,确认已收到主机B 的数据段:”我已收到回复,我现在要开始传输实际数据了</p>
<p>这样3次握手就完成了,主机A和主机B 就可以传输数据了.<br>3次握手的特点<br>没有应用层的数据<br>SYN这个标志位只有在TCP建产连接时才会被置1<br>握手完成后SYN标志位被置0<br>4次断开<br>1 当主机A完成数据传输后,将控制位FIN置1,提出停止TCP连接的请求<br>2 主机B收到FIN后对其作出响应,确认这一方向上的TCP连接将关闭,将ACK置1<br>3 由B 端再提出反方向的关闭请求,将FIN置1<br>4 主机A对主机B的请求进行确认,将ACK置1,双方向的关闭结束.<br>由TCP的三次握手和四次断开可以看出,TCP使用面向连接的通信方式,大大提高了数据通信的可靠性,使发送数据端<br>和接收端在数据正式传输前就有了交互,为数据正式传输打下了可靠的基础<br>名词解释<br>ACK TCP报头的控制位之一,对数据进行确认.确认由目的端发出,用它来告诉发送端这个序列号之前的数据段<br>都收到了.比如,确认号为X,则表示前X-1个数据段都收到了,只有当ACK=1时,确认号才有效,当ACK=0时,确认号无效,这时会要求重传数据,保证数据的完整性.<br>SYN 同步序列号,TCP建立连接时将这个位置1<br>FIN 发送端完成发送任务位,当TCP完成数据传输需要断开时,提出断开连接的一方将这位置1</p>
<p>解释原因：</p>
<p>TCP建立连接要进行3次握手,而断开连接要进行4次,这是由于TCP的半关闭造成的,因为TCP连接是全双工的(<br>即数据可在两个方向上同时传递)所以进行关闭时每个方向上都要单独进行关闭,这个单方向的关闭就叫半关闭.<br>关闭的方法是一方完成它的数据传输后,就发送一个FIN来向另一方通告将要终止这个方向的连接.当一端收到一个FIN,它必须<br>通知应用层TCP连接已终止了这个方向的数据传送,发送FIN通常是应用层进行关闭的结果.</p>
<p>另一种解释：</p>
<p>这是因为服务端的LISTEN状态下的SOCKET当收到SYN报文的建连请求后，它可以把ACK和SYN（ACK起应答作用，而SYN起同步作用）放在一个报文里来发送。但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未必会马上会关闭SOCKET,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。</p>
<p>为什么不能两次握手能进行连接？</p>
<p>我们知道，3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。<br>现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。<br>16.操作系统中的堆和栈的区别。数据结构中堆与栈的区别</p>
<p>操作系统中：<br>堆和栈的主要区别：</p>
<p>（1）管理方式不同。<br>栈编译器自动管理，无需程序员手工控制；而堆空间的申请释放工作由程序员控制，容易产生内存泄漏。</p>
<p>（2）空间大小不同。<br>栈是向低地址扩展的数据结构，是一块连续的内存区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，当申请的空间超过栈的剩余空间时，将提示溢出。因此，用户能从栈获得的空间较小。</p>
<p>堆是向高地址扩展的数据结构，是不连续的内存区域。因为系统是用链表来存储空闲内存地址的，且链表的遍历方向是由低地址向高地址。由此可见，堆获得的空间较灵活，也较大。栈中元素都是一一对应的，不会存在一个内存块从栈中间弹出的情况。</p>
<p>（3）是否产生碎片。<br>对于堆来讲，频繁的malloc/free（new/delete）势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低（虽然程序在退出后操作系统会对内存进行回收管理）。对于栈来讲，则不会存在这个问题。</p>
<p>（4）增长方向不同。<br>堆的增长方向是向上的，即向着内存地址增加的方向；栈的增长方向是向下的，即向着内存地址减小的方向。</p>
<p>（5）分配方式不同。<br>堆都是程序中由malloc()函数动态申请分配并由free()函数释放的；栈的分配和释放是由编译器完成的，栈的动态分配由alloca()函数完成，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行申请和释放的，无需手工实现。</p>
<p>（6）分配效率不同。<br>栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行。堆则是C函数库提供的，它的机制很复杂，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构/操作系统）在堆内存中搜索可用的足够大的空间，如果没有足够大的空间（可能是由于内存碎片太多），就有需要操作系统来重新整理内存空间，这样就有机会分到足够大小的内存，然后返回。显然，堆的效率比栈要低得多。</p>
<p>数据结构中：<br>堆和栈在数据结构中是两种不同的数据结构。 两者都是数据项按序排列的数据结构。</p>
<p>栈：像是装数据的桶或者箱子</p>
<p>栈是大家比较熟悉的一种数据结构，它是一种具有后进先出的数据结构，也就是说后存放的先取，先存放的后取，这就类似于我们要在取放在箱子底部的东西（放进去比较早的物体），我们首先要移开压在它上面的物体（放入比较晚的物体）。</p>
<p>堆：像是一颗倒立的大树</p>
<p>堆是一种经过排序的树形数据结构，每个节点都有一个值。通常我们所说的</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>Java子类与父类之间的转换</title>
    <url>/2017/09/26/Java%E5%AD%90%E7%B1%BB%E4%B8%8E%E7%88%B6%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<p>在使用Java的多态机制时，常常使用的一个特性便是子类和父类之间的对象转换。从子类向父类的转换称为向上转换（upcasting），通过向上转换，我们能够在编写程序时采用通用程序设计的思想，在需要使用子类对象的时候，通过把变量定义为父类型，我们可以通过一个变量，使用该父类型的所有子类型实例；从父类型向子类型的转换称为向下转换（downcasting），通过向下转换，我们能在必要的时候，将父类型变量转换成子类型变量，使用一些通过子类型才能够使用的方法。以下是我对于对象转换的一些个人理解，如有不对，欢迎指正，虚心向大神们请教。</p>
<p>首先是从子类向父类的向上转换。向上转换比较直观，总是能够将一个子类的实例转换为一个父类的对象，从继承链的角度，这个特性很容易理解：继承是一种“是一种”的关系，从父类派生出的子类，我们都能理解为，子类总是父类的一个实例。比如说，Fruit类派生出了Orange类，Apple类，Orange和Apple都是Fruit；Animal类派生出了Tiger类和Lion类，Tiger和Lion都是Animal。因此，从子类向父类的转换不需要什么限制，只需直接将子类实例赋值给父类变量即可，这也是Java中的多态的实现机制。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;Test.java</span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        Animal tiger &#x3D; new Tiger();</span><br><span class="line">        Animal lion &#x3D; new Lion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Animal &#123;</span><br><span class="line">    String name;</span><br><span class="line">    Animal() &#123;</span><br><span class="line">        name &#x3D; &quot;animal&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    Animal(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Tiger extends Animal &#123;</span><br><span class="line">    Tiger() &#123;</span><br><span class="line">        super(&quot;tiger&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Lion extends Animal &#123;</span><br><span class="line">    Lion() &#123;</span><br><span class="line">        super(&quot;lion&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而从父类向子类的向下转换就稍微复杂一些了。在讲述向下转换之前，也许有些刚学java的朋友会有点不解为什么要使用向下转换，使用多态和动态绑定机制通过父类型变量使用子变量不就可以了么（比如我就曾对此感到疑惑）。这就要考虑到，在继承关系中，有一些方法是不适合由父类定义并由子类继承并重写的，有些方法是子类特有的，不应该通过继承得到，且子类可能也会有自己特有的成员变量，那么在使用多态机制的时候，若我们要通过父类型变量使用到这些子类特有的方法和属性的话，就需要将服类型变量转换成对应的子类型变量。一个典型例子便是标准库中的数据类型包装类：Integer类，Double类，Long类等，它们都继承自Number类，且它们都有一个方法叫做compareTo用于比较两个同样的类型。然而这个方法是这些子类通过实现Comparable接口来实现的，在Number类中并没有该方法的实现，因此若要通过Number类型变量来使用compareTo方法，就要先将Number类转换成子类的对象。</p>
<p>从父类向子类的转换就有限制了。首先，父类变量向子类转换必须通过显式强制类型转换,采取和向上转换相同的直接赋值方式是不行的，；并且，当把一个父类型变量实例转换为子类型变量时，必须确保该父类变量是子类的一个实例，从继承链的角度来理解这些原因：子类一定是父类的一个实例，然而父类却不一定是子类的实例；比如说，Fruit未必是Orange，它可能是Apple；Animal也不一定是Tiger，它可能是Lion。用代码来解释一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Animal tiger &#x3D; new Tiger();</span><br><span class="line">Animal lion &#x3D; new Lion();</span><br></pre></td></tr></table></figure>
<p>在前面向上转换的代码示例当中，main方法中的这两行代码，意思就是父类型变量tiger是子类Tiger的一个实例，lion是Lion的一个实例。<br>也就是说，如果要把tiger转换为Tiger类型，必须保证tiger本身是Tiger的一个实例，在上例中，如果要把tiger转换成Lion类型，或是把Lion类型转换为Tiger类型，都是行不通的，在运行时，这会抛出一个运行异常ClassCastException，表示类转换异常。因此，在进行父类向子类的转换时，一个好的习惯是通过instanceof运算符来判断父类变量是否是该子类的一个实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Tiger t &#x3D; null;</span><br><span class="line">if(tiger instanceof Tiger)</span><br><span class="line">    t &#x3D; (Tiger)tiger;</span><br></pre></td></tr></table></figure>
<p>如果要通过父类调用子类变量的方法，那么要注意要将父类型变量和强制转换用括号括起来：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Number i &#x3D; new Integer(3)；</span><br><span class="line">System.out.println(</span><br><span class="line">    ((Integer)i).compareTo(new Integer(4))</span><br><span class="line">                  ）；</span><br></pre></td></tr></table></figure>
<p>因为成员访问运算符.的优先级大于类型转换，所以要用括号括起来保证类型转换先于成员访问进行运算。<br>前面说到用instanceof判断父类是否是子类的一个实例是一个好习惯，如果不养成这个习惯的话很容易出问题，请看下面这段代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Animal animal &#x3D; new Tiger();</span><br><span class="line">Lion lion &#x3D; (Lion)animal;</span><br></pre></td></tr></table></figure>
<p>前面说到，这段代码会在运行时抛出ClassCastException异常，然而，这段代码却是能够编译成功的。原因是因为，Java编译器并没有聪明到能够在编译阶段就知道父类型变量是哪一个子类的实例，所以，将animal转换为Lion类型的代码：(Lion)animal是能够编译通过的，即使事实上我们能看到animal是Tiger的一个实例，因为Animal类型确实能转换成Lion类型，所以这条语句是合法的。所以，如果没有使用instanceof防止不同子类型之间的对象转换，而又不能指望编译器检查出这种转换逻辑错误的话，就很容易犯错了。<br>总结</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ConvertPro extends Father &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Father father &#x3D; new Father();</span><br><span class="line">        Father father1 &#x3D; new ConvertPro();</span><br><span class="line">        ConvertPro son &#x3D; new ConvertPro();</span><br><span class="line">        &#x2F;&#x2F; ConvertPro son1 &#x3D; (ConvertPro) new Father();</span><br><span class="line">        &#x2F;&#x2F; son &#x3D; (ConvertPro)father;</span><br><span class="line">        son &#x3D; (ConvertPro) father1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * 父类</span><br><span class="line"> * </span><br><span class="line"> * @author icer</span><br><span class="line"> * </span><br><span class="line"> *&#x2F;</span><br><span class="line">class Father &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码注释掉的两行是会运行错误的. 根据代码显示, 只有我们的父类对象本身就是用子类new出来的时候, 才可以在将来被强制转换为子类对象.</p>
<p>子类继承父类的所有(包括属性以及方法), 也就是说子类包含的内容应该是比父类要大的. 如果正常环境下, 把一个父类转换成子类一定会损失精度. 但是如果父类对象本身就是用子类去new出来的, 就类似于一个本来就是儿子角色的人, 去装了一会儿父亲, 这个角色是可以在未来转换回去的, 但是一个父亲, 永远不可能去装儿子的.</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多态</tag>
      </tags>
  </entry>
  <entry>
    <title>一道题目引发的思考</title>
    <url>/2017/09/26/%E4%B8%80%E9%81%93%E9%A2%98%E7%9B%AE%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<p>在看一份Java面试题集的时候遇到一个这样的问题：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">        public static void main(String[] args)&#123;</span><br><span class="line">            Father father &#x3D; new Father();</span><br><span class="line">            Father child &#x3D; new Child();</span><br><span class="line">            System.out.println(father.getName());</span><br><span class="line">            System.out.println(child.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class Father&#123;</span><br><span class="line">        public static String getName()&#123;</span><br><span class="line">            return &quot;Father&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class Child extends Father&#123;</span><br><span class="line">        public static String getName()&#123;</span><br><span class="line">            return &quot;Child&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>请问输出的结果是：<br>结果是都是Father。<br>为什么呢？</p>
<p>我们看到这里的都是子类 ， 父类的静态方法。第一个输出为Father我们不奇怪，但是第二个为啥也是Father呢？为什么不是调用子类的静态方法呢？<br>我们看到，子类对象被父类变量所引用，这里是想测验我们，父类的实例方法能否被子类重写，如果重写了，那么调用这个方法，就应该输出子类的相关信息。要是不能，那就是调用父类的静态方法了。<br>解释</p>
<p>父类代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Fu &#123;  </span><br><span class="line">    public static void show() &#123;  </span><br><span class="line">        System.out.println(&quot;父类的静态方法&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">    public void method() &#123;  </span><br><span class="line">        System.out.println(&quot;父类的普通方法&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">子类代码：</span><br><span class="line"></span><br><span class="line">public class Zi extends Fu &#123;  </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        Fu fu &#x3D; new Zi();  </span><br><span class="line">        fu.show();  </span><br><span class="line">        fu.method();  </span><br><span class="line">    &#125;  </span><br><span class="line">    public static void show() &#123;  </span><br><span class="line">        System.out.println(&quot;子类的静态方法&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">    public void method() &#123;  </span><br><span class="line">        System.out.println(&quot;子类的普通方法&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这里我们可以看出，父类的静态方法是不能被子类重写的，其实重写只能适用于实例方法，不能用于静态方法，对于上面这种静态方法而言，我们应该称之为隐藏。<br>Java静态方法形式上可以重写，但从本质上来说不是Java的重写。因为静态方法只与类相关，不与具体实现相关。声明的是什么类，则引用相应类的静态方法(本来静态无需声明，可以直接引用)。并且static方法不是后期绑定的，它在编译期就绑定了。换句话说，这个方法不会进行多态的判断，只与声明的类有关。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>静态方法</tag>
      </tags>
  </entry>
  <entry>
    <title>Java构造函数详解</title>
    <url>/2017/09/26/Java%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>当我们新实例化一个对象的时候，都想对这个对象做一些初始化的工作，比如给对象的属性初始化相关的值。这就是构造函数要做的事。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class People&#123;</span><br><span class="line">	public String name;</span><br><span class="line">	    public int age;</span><br><span class="line">	    public People(String name,int age) &#123;</span><br><span class="line">	        this.age &#x3D; age;</span><br><span class="line">	        this.name &#x3D; name;</span><br><span class="line">	    &#125;</span><br><span class="line">	    public People(int age,String name)&#123;</span><br><span class="line">	</span><br><span class="line">	    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="构造函数的作用"><a href="#构造函数的作用" class="headerlink" title="构造函数的作用"></a>构造函数的作用</h3><p>构造方法作用：对对象进行初始化.<br>构造函数和普通的函数（方法）有啥区别？</p>
<p>（1）. 一般函数是用于定义对象应该具备的功能。而构造函数定义的是，对象在调用功能之前，在建立时，应该具备的一些内容。也就是对象的初始化内容。</p>
<p>（2）. 构造函数是在对象建立时由jvm调用, 给对象初始化。一般函数是对象建立后，当对象调用该功能时才会执行。</p>
<p>（3）. 普通函数可以使用对象多次调用，构造函数就在创建对象时调用。</p>
<p>（4）. 构造函数的函数名要与类名一样，而普通的函数只要符合标识符的命名规则即可。</p>
<p>（5）. 构造函数没有返回值类型。<br>构造函数使用时的细节</p>
<p>（1）. 当类中没有定义构造函数时，系统会指定给该类加上一个空参数的构造函数。这个是类中默认的构造函数。当类中如果自定义了构造函数，这时默认的构造函数就没有了。</p>
<p>备注：可以通过javap命令验证。</p>
<p>（2）.在一个类中可以定义多个构造函数，以进行不同的初始化。多个构造函数存在于类中，是以重载的形式体现的。因为构造函数的名称都相同。<br>构造代码块</p>
<p>这个构造代码块有啥作用呢？注意构造代码块和静态块不一样。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class People&#123;</span><br><span class="line">    public String name;</span><br><span class="line">    public int age;</span><br><span class="line">    public People(String name,int age) &#123;</span><br><span class="line">        this.age &#x3D; age;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line">    public People(int age,String name)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;静态块</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;这是静态块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;这是构造代码块</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;这是构造代码块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造代码块的作用是：给所有的对象进行统一的初始化。<br>如果，构造函数中有比较多相同的部分，这样我们可以将它移出来，放在构造代码块中。<br>具体作用</p>
<p>1：给对象进行初始化。对象一建立就运行并且优先于构造函数。<br>与构造函数区别</p>
<p>2：构造代码块和构造函数的区别，构造代码块是给所有对象进行统一初始化， 构造函数给对应的对象初始化。</p>
<p>3：构造代码块的作用：它的作用就是将所有构造方法中公共的信息进行抽取。</p>
<h3 id="需要注意的是："><a href="#需要注意的是：" class="headerlink" title="需要注意的是："></a>需要注意的是：</h3><p>在Java中，子类的构造过程中，必须 调用其父类的构造函数, 是因为有继承关系存在时, 子类要把父类的内容继承下来, 通过什么手段做到的？ 这样： 当你new一个子类对象的时候, 必须首先要new一个父类的对像出来, 这个父类对象位于子类对象的内部, 所以说，子类对象比父类对象大, 子类对象里面包含了一个父类的对象, 这是内存中真实的情况.</p>
<p>构造方法是new一个对象的时候, 必须要调的方法, 这是规定, 要new父类对象出来, 那么肯定要调用其构造方法, 所以 第一个规则：子类的构造过程中，必须 调用其父类的构造方法</p>
<p>一个类, 如果我们不写构造方法, 那么编译器会帮我们加上一个默认的构造方法, 所谓默认的构造方法, 就是没有参数的构造方法, 但是如果你自己写了构造方法, 那么编译器就不会给你添加了</p>
<p>所以有时候当你new一个子类对象的时候，肯定调用了子类的构造方法，但是在子类构造方法中我们并没有显示的调用基类的构造方法，就是没写，如：super(); 并没有这样写，但是</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用Java写一个简易的HTTPServer</title>
    <url>/2017/09/21/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Java%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E7%9A%84HTTPServer/</url>
    <content><![CDATA[<h3 id="HTTP是啥？"><a href="#HTTP是啥？" class="headerlink" title="HTTP是啥？"></a>HTTP是啥？</h3><p>   超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。1960年美国人Ted Nelson构思了一种通过计算机处理文本信息的方法，并称之为超文本（hypertext）,这成为了HTTP超文本传输协议标准架构的发展根基。Ted Nelson组织协调万维网协会（World Wide Web Consortium）和互联网工程工作小组（Internet Engineering Task Force ）共同合作研究，最终发布了一系列的RFC，其中著名的RFC 2616定义了HTTP 1.1。<br>反正就是一种传输协议，满足这样的传输协议的双方可以实现交互的功能。</p>
<h3 id="Server是啥？"><a href="#Server是啥？" class="headerlink" title="Server是啥？"></a>Server是啥？</h3><p>Server就是我们所说的服务器，就是监听在某个端口的服务程序，这个服务程序一直等待客户端发来的请求，然后根据HTTP协议，处理客户端的请求，然后返回结果给客户端。绝大多数的服务器实现都是socket编程，有些编程语言提供了很方便的socket api来实现服务端的编程。当然我们的Java也是提供了非常好的api来帮助我们实现服务端的编程。<br>如何使用Java来实现呢？</p>
<p>在web的最初阶段是不支持web服务器与用户的交互的.也就是说web服务器不能动态的生成用户要访问的页面,web服务器提供给用户的页面都是提前生成好的.所以也说这种页面是静态页面.<br>比如说用户请求访问<a href="http://localhost:8088/hello1.htm" target="_blank" rel="noopener">http://localhost:8088/hello1.htm</a>, 那么web服务器从自己的想要目录下获取hello1.htm(已经存在).然后通过HTTP协议返回给用户.</p>
<p>下面我们来模拟一下这个过程.因为HTTP协议是应用层协议,基于TCP,所以我们用Java的socket来编写HTTP服务器.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package HTTPServer;</span><br><span class="line">import java.io.*;</span><br><span class="line">import java.net.ServerSocket;</span><br><span class="line">import java.net.Socket;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * Created by Administrator on 2017&#x2F;9&#x2F;21.</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class HTTPServer2 &#123;</span><br><span class="line">    &#x2F;&#x2F;端口</span><br><span class="line">    private final static int port &#x3D; 8000;</span><br><span class="line">    private ServerSocket serverSocket &#x3D; null;</span><br><span class="line">    &#x2F;&#x2F;启动一个服务端口,并监听在8000端口</span><br><span class="line">    public HTTPServer2() throws Exception&#123;</span><br><span class="line">        this.serverSocket &#x3D; new ServerSocket(port);</span><br><span class="line">        System.out.println(&quot;启动端口：&quot;+port);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;获得客户端发来的请求字符串</span><br><span class="line">    public String getRequest(Socket socket)&#123;</span><br><span class="line">        byte[] requestBuffer &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;获得客户端口的输入流</span><br><span class="line">            InputStream inputStream &#x3D; socket.getInputStream();</span><br><span class="line">            &#x2F;&#x2F;获得输入流多少个字节的数据准备就绪</span><br><span class="line">            int size &#x3D; inputStream.available();</span><br><span class="line">            &#x2F;&#x2F;将流数据存入一个字节数组</span><br><span class="line">             requestBuffer &#x3D; new byte[size];</span><br><span class="line">            inputStream.read(requestBuffer);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;将字节数组转化为字符串，并返回</span><br><span class="line">        return new String(requestBuffer);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;从request字符串中处理URI</span><br><span class="line">    public String getURI(String requestString)&#123;</span><br><span class="line">        String firstLine &#x3D; requestString.substring(0,requestString.indexOf(&quot;\r\n&quot;));</span><br><span class="line">        String[] parts &#x3D; firstLine.split(&quot; &quot;);</span><br><span class="line">        System.out.println(parts);</span><br><span class="line">        return parts[1];</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;获得响应的类型</span><br><span class="line">    public String getContentType(String URI)&#123;</span><br><span class="line">         &#x2F;* 决定HTTP响应正文的类型 *&#x2F;</span><br><span class="line">         String contentType;</span><br><span class="line">         if (URI.indexOf(&quot;html&quot;)!&#x3D;-1||URI.indexOf(&quot;htm&quot;)!&#x3D;-1)&#123;</span><br><span class="line">             contentType &#x3D; &quot;text&#x2F;html&quot;;</span><br><span class="line">         &#125;else if (URI.indexOf(&quot;jpg&quot;) !&#x3D; -1 || URI.indexOf(&quot;jpeg&quot;) !&#x3D; -1)&#123;</span><br><span class="line">             contentType &#x3D; &quot;image&#x2F;jpeg&quot;;</span><br><span class="line">         &#125; else if (URI.indexOf(&quot;gif&quot;) !&#x3D; -1)&#123;</span><br><span class="line">             contentType &#x3D; &quot;image&#x2F;gif&quot;;</span><br><span class="line">         &#125; else&#123;</span><br><span class="line">             contentType &#x3D; &quot;application&#x2F;octet-stream&quot;;</span><br><span class="line">         &#125;</span><br><span class="line">         return contentType;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;获得返回的文本数据流，即客户端请求的数据</span><br><span class="line">    public InputStream getResponseContent(String URI)&#123;</span><br><span class="line">        InputStream htmlInputStream &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            String fileName &#x3D; URI.split(&quot;&#x2F;&quot;)[1];</span><br><span class="line">            &#x2F;&#x2F;获得当前路径1</span><br><span class="line">            File fileDir &#x3D; new File(&quot;&quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                String abslutePath &#x3D; fileDir.getAbsolutePath();</span><br><span class="line">                System.out.println(abslutePath);</span><br><span class="line">            &#125;catch (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;获得当前路径2</span><br><span class="line">            String path&#x3D; System.getProperty(&quot;user.dir&quot;);</span><br><span class="line">            System.out.println(path);</span><br><span class="line">            htmlInputStream &#x3D; new FileInputStream(new File(path+&quot;\\&quot;+fileName));</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return htmlInputStream;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;组装响应头</span><br><span class="line">    public String assembleResponseHeader(String URI,String contentType)&#123;</span><br><span class="line">        &#x2F;* 创建HTTP响应结果 *&#x2F;</span><br><span class="line">        &#x2F;&#x2F; HTTP响应的第一行</span><br><span class="line">        String responseFirstLine &#x3D; &quot;HTTP&#x2F;1.1 200 OK\r\n&quot;;</span><br><span class="line">        &#x2F;&#x2F;响应头</span><br><span class="line">        String responseHeader &#x3D; &quot;Content-Type:&quot;+contentType+&quot;\r\n\r\n&quot;;</span><br><span class="line">        return responseFirstLine+responseHeader;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;处理请求</span><br><span class="line">    public void service() throws InterruptedException  &#123;</span><br><span class="line">        while (true)&#123;</span><br><span class="line">            Socket socket &#x3D; null;</span><br><span class="line">            try &#123;</span><br><span class="line">                socket &#x3D; serverSocket.accept();</span><br><span class="line">                String request &#x3D; this.getRequest(socket);</span><br><span class="line">                System.out.println(&quot;HttpServer receive request:\n&quot; + request);</span><br><span class="line">                String URI &#x3D; this.getURI(request);</span><br><span class="line">                System.out.println(URI);</span><br><span class="line">                String contentType &#x3D; this.getContentType(URI);</span><br><span class="line">                System.out.println(contentType);</span><br><span class="line">                &#x2F;&#x2F;往端口返回数据</span><br><span class="line">                OutputStream outputStream &#x3D; socket.getOutputStream();</span><br><span class="line">                outputStream.write(this.assembleResponseHeader(URI,contentType).getBytes());</span><br><span class="line">                int length &#x3D; 0;</span><br><span class="line">                byte[] buffer &#x3D; new byte[128];</span><br><span class="line">                &#x2F;&#x2F;获得了文本文件的字节流</span><br><span class="line">                &#x2F;&#x2F;需要写入到客户端口</span><br><span class="line">                InputStream inputStream &#x3D; this.getResponseContent(URI);</span><br><span class="line">                while ((length &#x3D; inputStream.read(buffer))!&#x3D;-1)&#123;</span><br><span class="line">                    outputStream.write(buffer,0,length);</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F;模仿网络传输</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            HTTPServer2 httpServer2 &#x3D; new HTTPServer2();</span><br><span class="line">            httpServer2.service();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们准备一个简单的html文本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;HelloWorld&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body &gt;</span><br><span class="line">  &lt;h1&gt;Hello&lt;&#x2F;h1&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<p>保存为Hello.html,启动HTTPServer,在浏览器访问<a href="http://localhost:8088/hello1.html,我们在输出界面看到：" target="_blank" rel="noopener">http://localhost:8088/hello1.html,我们在输出界面看到：</a></p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/Hello.html</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: localhost:8088</span><br><span class="line"><span class="attribute">Connection</span>: keep-alive</span><br><span class="line"><span class="attribute">Cache-Control</span>: max-age=0</span><br><span class="line"><span class="attribute">Accept</span>: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span><br><span class="line"><span class="attribute">User-Agent</span>: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/43.0.2357.125 Safari/537.36</span><br><span class="line"><span class="attribute">Accept-Encoding</span>: gzip, deflate, sdch</span><br><span class="line"><span class="attribute">Accept-Language</span>: zh-CN,zh;q=0.8,en-US;q=0.6,en;q=0.4</span><br></pre></td></tr></table></figure>
<p>注意：我们的html文件需要放在我们工程目录下。或者可以根据我们服务器所在的文件，获得他们的路径，在定位我们的文件位置。<br>总结一下</p>
<p>socket编程，我们使用一个ServerSocket等待在指定端口处，知道客户端发来请求，我们知道网络中传输的都是字节，所以当我们要解析请求的字节数据，通常的方式是将字节转化为字符，然后分割得到我们HTTP请求的各部分，比如请求第一行，请求头。获得了这些之后，我们就可以进行一些处理，然后返回的我们的结果。<br>结果的返回，在程序中我们也是先使用字符来构建我们的响应，然后将字符串转化为字节数组，如果是文件，我们也可以将文件读取分批次读取到一个数组中，然后在依次写入到输出流中，即返回我们的字节数据给客户端。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>如何正确的学习一门技能</title>
    <url>/2017/07/06/%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%B8%80%E9%97%A8%E6%8A%80%E8%83%BD/</url>
    <content><![CDATA[<h3 id="左右脑模式"><a href="#左右脑模式" class="headerlink" title="左右脑模式"></a>左右脑模式</h3><p>在这里，我不知道有多少人听过笑来老师讲过学东西，其实有两种模式，一种叫苍蝇模式，一种叫蜜蜂模式。其实我现在讲的东西有异曲同工之妙。左右脑模式、 更精确地说，一般人其实没有意识到，进行一项学习，其实调用的 是两种模式。、 一种叫左脑模式，利用逻辑分析学习、 一种叫右脑学习模式，利用感知学习。为什么在学编程前，我要教各位元学习呢?元学习这个字，意思其实就是学习如何学习再学习。我希望教会各位不只一样技能的学习方式。在这里我要教会你另外一个 技能，这个技能叫做画画。新手如何学画画、 一般来说，画画甚至比编程更难学习。但我在这里要介绍一个在80 年代被发明的学画学习方式，这堂课只要5天，就能够让新手五天学会绘画。我是在一本书上看到的，这本书也推荐大家去买:《像艺术家一样思考》。 这本书的作者叫做 Betty Edwards，他是一位认知学家+画家。 在80年代时，她发明了一个让新手五天学会绘画的方法。这个方法很简单:当中的原理是这样的：就是让新手在刚开始学素描时，倒着画自己的自画像，他发现当学生正着画自己的自画像时，通常会画的七歪扭八。学生因为熟悉自己的样貌，所以作画时会纠结细节，一直想要去修改自己所呈现的容貌。问题是新手又没有足够的绘画技巧，于是就会画得一团糟。但是如果让学生将自己的照片反过来，临墓作画时，这时候突然间他们就会画了。正因为自己都不知道自己在画什么，所以纠结比较的那一个部分会被关掉。反而会把重点放在观察全局与细节。因此倒过来的作品远比正着画的作品水准高上太多。Betty发现的这个现象，正是因为人类的左右脑具有不同的运作模 式。前者注重逻辑分析与细节，后者注重全局观。正着画图，让我们不由自主的在针对自己应该熟悉的部分开启左脑分析模式。但是我们又不具备绘画的功力，导致一直绊倒自己。 他发现用这个方法，就可以让没有受过学习训练的人，直接强制关掉左脑的分析模式，专注在全局。其实学习英语以及编程，也是同样的道理。正因为语言或者是编程内使用的英语单词是我们熟悉的语言，在学习时，学习者会不自主地开启分析模式。去试图找到与过往经验匹配的模式，但是若匹配不到或匹配错误，学习者就会自己绊倒自己。</p>
<p>人人都该用英语、 所以为什么很多网上的学习英语的有效技巧，都要求学习者不要试图去记单词，能够的话，就是大量的去听别人说什么，大量的去模仿说句子、 这其实就是让学习者大量的使用右脑的直觉以及其他身体感觉， 去快速抓到全局感，拼出基础框架。而学英语最有效的方式:甚至是、直接到说英语的地区去居住、 在这样的情境下，学习者可以大量的模仿、大量的使用累积出的简单框架、 在当地生活购物，累积更强的语感与成就感、 大脑无法用未知解释未知、 同样的，编程也是相同的道理。一开始学习编程，初学者甚至不应该尝试着去搞懂里面的用法，因为人类的大脑无法用未知解释未知，就算看了一整天，你也无法用逻辑分析出所以然。学习编程最有效的方式就是冲进度。你只需要知道输入什么能够得出什么就可以了。看着一本小书，用模仿复制代码的方式，快速搭建出一个小项目，建立一个大致全局感。然后，将项目发布，让朋友称赞你，取得有效的成就感，这样就可以激励自己继续学习编程。用这样的方式，你就可以抢在自己放弃之前，建立起正循环了。<br>为什么要采纳这样的学习方法呢?<br>一般人学习之所以低效，是因为不了解自己的大脑怎么运作。一旦你开始了解自己的大脑是怎么运作的，很快的，你就会发现学习是有套路的，而且你可以利用这套方法，大幅拉升自己的学习初速度。在这里我先告诉各位五个结论:</p>
<pre><code>大脑并不擅长思考，而且大脑的思考是很缓慢的、
多数的思考，并不是真的思考，而是调用过去记忆所组成的结果
人是利用已知的事务理解新的事物，但理解其实是记忆
没有重复的练习，不可能精通任何脑力活
题海战术以及填鸭教育，有时是必须的</code></pre><h3 id="大脑并不善于思考、"><a href="#大脑并不善于思考、" class="headerlink" title="大脑并不善于思考、"></a>大脑并不善于思考、</h3><p>在这社会上我们最常嘲讽的一个现象：大多数人是不用脑子思考的。其实这真是事实，你仔细想想，其实大脑真是用来思考的吗?如果你叫大脑随便做一则演算，其实大脑的演算，往往是比我们现在所发明的计算机来说，效率是极其低的。做个7X8的数学还行，但要是改个177X288的快速演算。就瞬间就短路。在这里，我举一个大脑其实不善于思考的例子。<br>一个空屋子里有一支蜡烛，一些火柴，和一盒图钉。目标是让点燃的蜡烛离地五英尺高，你已经尝试把蜡烛底部沾上蜡液，但还是沾不到墙上，怎样才不用手扶，让点燃的蜡烛离地五英尺高?这一个题目，正常一般人在看到题目后，很少能在2分钟内给出解决答案。但是如果你把这个题目具象化，也就是真的生出这些设备，放在眼前。你就会发现这道题目的答案其实并不难。你只要把图钉倒出来，把盒子用图钉钉在墙壁上，再把蜡烛豁在盒子里，就完成了这个任务。</p>
<h3 id="大脑的，思考特性、"><a href="#大脑的，思考特性、" class="headerlink" title="大脑的，思考特性、"></a>大脑的，思考特性、</h3><p>这个例子解释了思考的几个特性。首先，大脑的思考是很缓慢的。接看，思考是很费力的。大脑很难凭空想像出这个场景并运算出解答。甚至可能完全答不出来。但是如果把大脑接上视觉系统与触觉系统。因为视觉系统与触觉系统进行了可靠的回传，大脑实质上是调用了其他地区可用的资源做运算。就能迅速得出答案。那么，既然思考那么费力。我们平时是怎么样不费工夫的做出日常生活中的各样决策?习惯！答案是：习惯。习惯就是我们做过某件事的记忆回路，大脑调用过去的记忆，让身体自动做出判断。所以，在这里，我们要引出今天要介绍的第二条认知学事实：大部分人做的决策，其实真不是基于大脑所做的思考，他们是记忆组成的结果、多数的思考，并不是真的思考，而是调用过去记忆所组成的结果、大脑的运作原理是这样的：接收到环境刺激然后把决策放到工作记忆上。熟练之后烧到长期记忆中(事实性知识、过程性知识)。工作记忆就是我们当前正在意识、思考的工作区域。以计算机比喻，就是电脑的内存。容量小，资料存在时间短， 重开机就不见了。长期记忆就是我们长久以来储存的事实性知识、经验。(以计算机比喻，就是电脑的硬盘。容量大，资料存在时间长， 可以长期复用。而长期以来，我们日常遇到的大量决策，事实上是调用了长期记忆 (经验以及不变的科学事实)，自动完成。而所谓的解题与思考，是复用了短期记忆以及长期记忆而成。比如说以197X288这个例子、7X8是长期记忆，是我们小时候背的九九乘法。接下来我们要算170 “ 280。你知道这有多难、 人类几乎很难凭空展开这个算式。 这是因为人类的大脑工作记忆中只能暂时存放结果(对人类无意义的结果)。人类事实上很少在思考，更多的是调用记忆在做决策。 人是利用已知的事务理解新的事物，但理解其实是记忆、 理解其实不是一个调用大脑思考的过程，而是一个匹配记忆的过程。很多行业为什么不喜欢招小白，事实上就是因为小白经验过少，缺乏太多相关记忆，可以直接匹配学习。又或者是为什么一般人难以上手编程，而且对于学习编程，感受到痛苦。这事实上就是因为编程里面的知识，跟过往几乎所有的生活环境运作原理几乎是不匹配的，所以造成无法理解，而大量调用</p>
<p>Ps: 本文转载于某个论坛网站，觉得挺有道理的，顾摘录共勉。</p>
]]></content>
      <categories>
        <category>杂文随想</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>技能</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的final关键字</title>
    <url>/2017/06/09/Java%E4%B8%AD%E7%9A%84final%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<p>Java中的final关键字非常重要，它可以应用于类、方法以及变量。这篇文章中我将带你看看什么是final关键字？将变量，方法和类声明为final代表了什么？使用final的好处是什么？最后也有一些使用final关键字的实例。final经常和static一起使用来声明常量，你也会看到final是如何改善应用性能的。</p>
<h3 id="final关键字的含义"><a href="#final关键字的含义" class="headerlink" title="final关键字的含义?"></a>final关键字的含义?</h3><p>final在Java中是一个保留的关键字，可以声明成员变量、方法、类以及本地变量。一旦你将引用声明作final，你将不能改变这个引用了，编译器会检查代码，如果你试图将变量再次初始化的话，编译器会报编译错误。</p>
<h3 id="什么是final变量？"><a href="#什么是final变量？" class="headerlink" title="什么是final变量？"></a>什么是final变量？</h3><p>凡是对成员变量或者本地变量(在方法中的或者代码块中的变量称为本地变量)声明为final的都叫作final变量。final变量经常和static关键字一起使用，作为常量。下面是final变量的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static final String LOAN &#x3D; &quot;loan&quot;;</span><br><span class="line">LOAN &#x3D; new String(&quot;loan&quot;) &#x2F;&#x2F;invalid compilation error</span><br></pre></td></tr></table></figure>
<p>可以看出final变量是只读的。</p>
<h3 id="什么是final方法"><a href="#什么是final方法" class="headerlink" title="什么是final方法?"></a>什么是final方法?</h3><p>final也可以声明方法。方法前面加上final关键字，代表这个方法不可以被子类的方法重写。如果你认为一个方法的功能已经足够完整了，子类中不需要改变的话，你可以声明此方法为final。final方法比非final方法要快，因为在编译的时候已经静态绑定了，不需要在运行时再动态绑定。下面是final方法的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">class PersonalLoan&#123;</span><br><span class="line">    public final String getName()&#123;</span><br><span class="line">        return &quot;personal loan&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class CheapPersonalLoan extends PersonalLoan&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public final String getName()&#123;</span><br><span class="line">        return &quot;cheap personal loan&quot;; &#x2F;&#x2F;compilation error: overridden method is final</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="什么是final类？"><a href="#什么是final类？" class="headerlink" title="什么是final类？"></a>什么是final类？</h3><p>使用final来修饰的类叫作final类。final类通常功能是完整的，它们不能被继承。Java中有许多类是final的，譬如String, Interger以及其他包装类。下面是final类的实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final class PersonalLoan&#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    class CheapPersonalLoan extends PersonalLoan&#123;  &#x2F;&#x2F;compilation error: cannot inherit from final class</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="final关键字的好处"><a href="#final关键字的好处" class="headerlink" title="final关键字的好处"></a>final关键字的好处</h3><p>下面总结了一些使用final关键字的好处<br>final关键字提高了性能。JVM和Java应用都会缓存final变量。<br>final变量可以安全的在多线程环境下进行共享，而不需要额外的同步开销。<br>使用final关键字，JVM会对方法、变量及类进行优化。</p>
<p>不可变类</p>
<p>创建不可变类要使用final关键字。不可变类是指它的对象一旦被创建了就不能被更改了。String是不可变类的代表。不可变类有很多好处，譬如它们的对象是只读的，可以在多线程环境下安全的共享，不用额外的同步开销等等。<br>为什么String是不可变的以及如何写一个不可变类。</p>
<p>因为String类是被final修饰了，写一个不可变类就是用final去修饰它。</p>
<h3 id="关于final的重要知识点"><a href="#关于final的重要知识点" class="headerlink" title="关于final的重要知识点"></a>关于final的重要知识点</h3><ul>
<li>final关键字可以用于成员变量、本地变量、方法以及类。</li>
<li>final成员变量必须在声明的时候初始化或者在构造器中初始化，否则就会报编译错误。</li>
<li>你不能够对final变量再次赋值。</li>
<li>本地变量必须在声明时赋值。</li>
<li>在匿名类中所有变量都必须是final变量。</li>
<li>final方法不能被重写。</li>
<li>final类不能被继承。</li>
<li>final关键字不同于finally关键字，后者用于异常处理。</li>
<li>final关键字容易与finalize()方法搞混，后者是在Object类中定义的方法，是在垃圾回收之前被JVM调用的方法。</li>
<li>接口中声明的所有变量本身是final的。</li>
<li>final和abstract这两个关键字是反相关的，final类就不可能是abstract的。</li>
<li>final方法在编译阶段绑定，称为静态绑定(static binding)。</li>
<li>没有在声明时初始化final变量的称为空白final变量(blank final variable)，它们必须在构造器中初始化，或者调用this()初始化。不这么做的话，编译器会报错“final变量(变量名)需要进行初始化”。</li>
<li>将类、方法、变量声明为final能够提高性能，这样JVM就有机会进行估计，然后优化。</li>
</ul>
<p>   按照Java代码惯例，final变量就是常量，而且通常常量名要大写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private final int COUNT &#x3D; 10;</span><br></pre></td></tr></table></figure>
<pre><code>对于集合对象声明为final指的是引用不能被更改，但是你可以向其中增加，删除或者改变内容。譬如：</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private final List Loans &#x3D; new ArrayList();</span><br><span class="line">list.add(“home loan”);  &#x2F;&#x2F;valid</span><br><span class="line">list.add(&quot;personal loan&quot;); &#x2F;&#x2F;valid</span><br><span class="line">loans &#x3D; new Vector();  &#x2F;&#x2F;not valid</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>关键字</tag>
      </tags>
  </entry>
  <entry>
    <title>java中有package包，运行时”错误：找不到或无法加载主类</title>
    <url>/2017/06/03/%E8%BF%90%E8%A1%8C%E6%97%B6%E2%80%9D%E9%94%99%E8%AF%AF%EF%BC%9A%E6%89%BE%E4%B8%8D%E5%88%B0%E6%88%96%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BD%E4%B8%BB%E7%B1%BB/</url>
    <content><![CDATA[<p>java中的打包机制是为了防止程序多个地方出现相同的名字而将局部程序限定在一块的机制。打个比方，在湖北和湖南两个地方，都有一个叫张三的人，那么当我们寻找这个人的时候，就会出现错误：到底是湖北的张三，还是湖南的张三？为了解决这个问题，我们把湖北，湖南这两个地方的所有程序分别打包。调用张三的时候分别带上湖北.张三或者是湖南.张三。这样就不会出错了。打包其实就是新建了一个文件夹，然后把需要打包的程序放在这个文件夹下面。<br>要注意：</p>
<p>1，package必须是程序中可执行的第一行代码；</p>
<p>2，package语句只能有一句；</p>
<p>3，package命名要求包含的所有字符均为小写，同时不能有特殊字符；</p>
<p>4，package可以有多层，每一层有.隔开，例如：package china.hubei.wuhan;（China是一个文件夹，hubei是china下的一个文件夹，wuhan是hubei文件夹下的一个文件夹）</p>
<p>5，package语句后面的分号不要掉。​<br>package运用场合：</p>
<p>1.多个程序员负责同样的一个项目时，不能确保每一个程序员定义的函数名或变量名完全不一样，这个时候每个程序员可以分别将自己负责的部分打包；</p>
<p>2，一个程序员负责一个规模较大的项目，往往不能保证每一处的函数名或变量名完全不同，这时，可以将每一小块区域的部分打包。</p>
<p>总而言之，当遇到以后或者他处可能与之前重复的时候，最好打包处理之。</p>
<p>“错误：找不到或无法加载主类​”的原因往往有：1.环境变量处理不当；2，程序名称和入口函数不一样；3，程序中有package。我们主要说的是第三点。</p>
<p>例如，函数的第一行为：package msg;（函数名为test）</p>
<p>在编译的时候，我们应该是javac -d . ​test.java</p>
<p>（-d：表示生成目录，设置编译生成的class文件保存路径，路径与定义的包名和层次相关。</p>
<p>. ：表示在当前目录中生成。）</p>
<p>运行的时候，带上包名，即java msg.test</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java在方法调用时为啥不支持默认参数</title>
    <url>/2017/03/28/Java%E5%9C%A8%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E6%97%B6%E4%B8%BA%E5%95%A5%E4%B8%8D%E6%94%AF%E6%8C%81%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<h3 id="java不支持像其他语言如python，php，js，c-在方法中使用默认参数。"><a href="#java不支持像其他语言如python，php，js，c-在方法中使用默认参数。" class="headerlink" title="java不支持像其他语言如python，php，js，c++在方法中使用默认参数。"></a>java不支持像其他语言如python，php，js，c++在方法中使用默认参数。</h3><p>在学习java的时候，有个问题在编辑器里老是会提示语法不对，就是在我调用成员方法是尝试传入默认参数是。我之前的经验，比如python时，是支持传入默认参数，但是奇怪的是作为高级语言的java并不支持这一优秀的特性，于是我尝试寻找答案。<br>我们知道java中，方法重载是非常重要的面向对象的特性。</p>
<p>java的方法重载里面有这样的定义，在类中定义相同的方法名，但是只要参数数量不同，或是种类，或是顺序不同都会引发，在调用方法是，根据参数的样式，调用相同方法的不同实现。那么问题来了，如果java支持传入默认参数，就会和这个重载特性发生冲突。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//假设java有这样的写法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b=<span class="number">10</span>)</span></span>&#123;</span><br><span class="line">		System.out.print(a+b);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">		System.out.print(a);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Test t = <span class="keyword">new</span> Test();</span><br><span class="line">		t.print(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有个问题就是，它到底调用哪一个呢？按照分析，这个参数是符合上面的两个方法，这样就出现了歧义。</p>
<h3 id="所以为了不破坏java重载的特性，默认参数就没有加入到java里面，但是如果我们想要使用默认参数呢？怎么办？"><a href="#所以为了不破坏java重载的特性，默认参数就没有加入到java里面，但是如果我们想要使用默认参数呢？怎么办？" class="headerlink" title="所以为了不破坏java重载的特性，默认参数就没有加入到java里面，但是如果我们想要使用默认参数呢？怎么办？"></a>所以为了不破坏java重载的特性，默认参数就没有加入到java里面，但是如果我们想要使用默认参数呢？怎么办？</h3><p>俗话说，解铃还需寄铃人。同样你可以使用重载的特性来实现调用默认参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">		System.out.print(a+b);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line">		<span class="keyword">return</span> print(a,b);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">		Test.print(<span class="number">1</span>);</span><br><span class="line">		Test.print(<span class="number">1</span>,<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上实现了在传入一个参数是可以附带默认参数，但是要比较呆板的重载已有的方法，这是比较累人的，java虽然是一门非常优秀的编译型语言，但是它比较呆板，希望它会发展的越来越好，毕竟现在java有函数式相关的额内容了，以前是没有的。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>方法调用</tag>
      </tags>
  </entry>
  <entry>
    <title>部署手撕包菜磁力网站</title>
    <url>/2017/03/23/%E9%83%A8%E7%BD%B2%E6%89%8B%E6%92%95%E5%8C%85%E8%8F%9C%E7%A3%81%E5%8A%9B%E7%BD%91%E7%AB%99/</url>
    <content><![CDATA[<h3 id="最近有个群里的好友，希望我帮他解决一个问题：在win环境本地下，运行起来一个django项目（带有后端爬虫）"><a href="#最近有个群里的好友，希望我帮他解决一个问题：在win环境本地下，运行起来一个django项目（带有后端爬虫）" class="headerlink" title="最近有个群里的好友，希望我帮他解决一个问题：在win环境本地下，运行起来一个django项目（带有后端爬虫）"></a>最近有个群里的好友，希望我帮他解决一个问题：在win环境本地下，运行起来一个django项目（带有后端爬虫）</h3><p>因为是项目，所以在pycharm里调试时出现：<br>enter description here<br>因为是要安装oursql驱动mysql，但是一直安装不上，以为它依赖cython。所以我尝试下载<br>Oursql的源码包，准备在python目录下安装：<br>enter description here</p>
<p>但是出现：<br>enter description here</p>
<p>并没有用。<br>我就尝试安装cython，pip install cython 结果是：<br>还是不可以。。。。<br>enter description here<br>enter description here</p>
<p>我开始怀疑，是不是在win下本身就非常那运行，也就是说，这个网站项目，从开始就是在<br>Linux下运行的。因为项目中带有master，我就推断，应该是github上的项目。于是尝试了一下搜索。<br>enter description here</p>
<p>结果显而易见了。</p>
<h3 id="后来，好友就买了一台centos的服务器，按照教程，安装相关的库"><a href="#后来，好友就买了一台centos的服务器，按照教程，安装相关的库" class="headerlink" title="后来，好友就买了一台centos的服务器，按照教程，安装相关的库"></a>后来，好友就买了一台centos的服务器，按照教程，安装相关的库</h3><p>步骤如下：</p>
<ol>
<li>获取ssbc源代码<ul>
<li>环境检测（Ssbc当前版本是基于django1.8.1开发，所需python环境为python2.7.5以上。）<br>[root@localhost ~]# python -V<br>Python 2.7.5<br>执行python -V即可获取当前版本。<ul>
<li>获取ssbc安装包<br>[root@localhost <del>]# wget <a href="https://github.com/78/ssbc/archive/master.zip" target="_blank" rel="noopener">https://github.com/78/ssbc/archive/master.zip</a><br>[root@localhost</del>]# unzip master.zip<br>解压后你会发现在root根目录先有个文件夹ssbc-master.</li>
</ul>
</li>
</ul>
</li>
<li>安装MariaDB<ul>
<li>安装数据库及所需环境<br>[root@localhost ~]# yum install gcc<br>[root@localhost ~]# yum install gcc-c++<br>[root@localhost ~]# yum install python-devel<br>[root@localhost ~]# yum install mariadb<br>[root@localhost ~]# yum install mariadb-devel<br>[root@localhost ~]# yum install mariadb-server<br>[root@localhost]# wget <a href="https://raw.github.com/pypa/pip/master/contrib/get-pip.py" target="_blank" rel="noopener">https://raw.github.com/pypa/pip/master/contrib/get-pip.py</a><br>[root@localhost]# python get-pip.py<br>[root@localhost]# cd ssbc-master<br>[root@localhost ssbc-master]# pip install -r requirements.txt</li>
<li>创建ssbc数据库<br>[root@localhost ~]# service mariadb start //启动数据库<br>[root@localhost ~]# mysql -uroot -p<br>Enter password: (回车即可)<br>MariaDB [(none)]&gt; create database ssbc default character set utf8;<br>MariaDB [(none)]&gt; quit; //创建成功后退出</li>
</ul>
</li>
<li>Web设置<br>[root@localhost ssbc-master]#<br>[root@localhost ssbc-master]# python manage.py makemigrations<br>[root@localhost ssbc-master]# python manage.py migrate<br>[root@localhost ssbc-master]# python manage.py runserver 0.0.0.0:80 //启动ssbc<br>浏览器输入你的ip（如：54.43.43.43) 看网站是否能正常访问，正常则CTRL+C停止<br>[root@localhost ssbc-master]# python manage.py createsuperuser //输入用户名邮箱密码确认密码（创建管理账号）<br>[root@localhost ssbc-master]# nohup python manage.py runserver 0.0.0.0:80 &gt; /dev/zero &amp; //将网站服务放在后台运行</li>
<li>安装Sphinx<br>[root@localhost ssbc-master]# wget <a href="http://sphinxsearch.com/files/sphinx-2.2.9-1.rhel7.x86_64.rpm" target="_blank" rel="noopener">http://sphinxsearch.com/files/sphinx-2.2.9-1.rhel7.x86_64.rpm</a><br>[root@localhost ssbc-master]# yum install unixODBC unixODBC-devel postgresql-libs<br>[root@localhost ssbc-master]# rpm -ivh sphinx-2.2.9-1.rhel7.x86_64.rpm</li>
</ol>
<p>然后在服务器根目录创建文件夹： data 和 tem （两个文件夹）<br>然后在 data 目录创建文件夹： bt<br>然后在 bt 目录创建文件夹： index<br>然后在 index 目录创建文件夹： db 和 binlog （两个文件夹）<br>然后在 tem 目录创建文件夹： downloads</p>
<p>最后 给 data 以及 tem 文件夹赋予 755 或者 777 权限 （需要继承到子文件夹）</p>
<p>[root@localhost ssbc-master]# indexer -c sphinx.conf –all （all 前面是空格减号减号）<br>[root@localhost ssbc-master]# searchd –-config ./sphinx.conf (config前空格减号减号)</p>
<ol start="5">
<li>开启爬虫(workers目录下)</li>
<li>爬虫：执行：python simdht_worker.py （等2两分钟出现数据之后可以CTRL+C停止）</li>
<li>1 执行命令：nohup python simdht_worker.py &gt;/dev/zero &amp; （让爬虫在后台运行）</li>
<li>入库：执行：python index_worker.py （等待10分钟没有出现数据之后可以CTRL+C停止）</li>
<li>1 后台执行命令：nohup python index_worker.py &gt;/dev/zero &amp; （让爬虫在后台运行）</li>
</ol>
<h3 id="如果出现系统报错：EnvironmentError-mysql-config-not-found，很明显是没有mysql-config这个文件的，解决办法："><a href="#如果出现系统报错：EnvironmentError-mysql-config-not-found，很明显是没有mysql-config这个文件的，解决办法：" class="headerlink" title="如果出现系统报错：EnvironmentError: mysql_config not found，很明显是没有mysql_config这个文件的，解决办法："></a>如果出现系统报错：EnvironmentError: mysql_config not found，很明显是没有mysql_config这个文件的，解决办法：</h3><p>（1）ubuntu下</p>
<p>执行sudo apt-get install libmysqld-dev</p>
<p>（2）fedora下</p>
<p>执行 sudo yum install python-devel</p>
<p>若出现：my_config.h:没有那个文件或目录，就执行：sudo yum install mysql-devel</p>
<p>注意：yum也是python写的，默认是调用/usr/bin/python的，这是系统本身自带的python，自己安装的一般在/usr/local/bin/python，所以最好别把系统自带的python给卸载掉了，自己下载的python没有yum模块。</p>
<p>此时执行 find / -name mysql_config 在/usr/bin/下发现了这个文件</p>
<p>然后修改MySQL-python-1.2.3目录下的site.cfg文件</p>
<p>去掉mysql_config=XXX这行的注释，并改成mysql_config=/usr/bin/mysql_config（以mysql_config文件所在机器上的目录为准）</p>
<h4 id="Ps："><a href="#Ps：" class="headerlink" title="Ps："></a>Ps：</h4><ol>
<li>如果出现在安装gcc是提示失败或者奔溃，可以yum remove 重复的库<br>（Found 3 pre-existing rpmdb problem(s), ‘yum check’ output follows）</li>
<li>或者是更换yum源，比如国内的阿里</li>
<li>数据库修改密码<br>enter description here<br>enter description here</li>
</ol>
<p>当我在ssh中运行，结果成功了。感动。</p>
<p>Bingo<br>结束折腾的两天，谢谢自己！谢谢google。</p>
]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>网站部署</tag>
        <tag>磁力</tag>
      </tags>
  </entry>
  <entry>
    <title>关于pymysql的使用</title>
    <url>/2017/03/23/%E5%85%B3%E4%BA%8Epymysql%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="什么是pymysql"><a href="#什么是pymysql" class="headerlink" title="什么是pymysql"></a>什么是pymysql</h3><pre><code>pymysql是一个python连接mysql数据库的驱动，用来实现通过python可以向mysql数据库中，进行数据库的操作。</code></pre><h3 id="为什么要用pymysql"><a href="#为什么要用pymysql" class="headerlink" title="为什么要用pymysql"></a>为什么要用pymysql</h3><pre><code>pymysql是纯python实现的，在跨平台的时候，基本上没有其他的副作用。
虽说是纯python实现的，但是它的效率还是不错的，虽然没有比C的实现那么有效率，但是pymysql还是可以的。
mysql的python官方驱动目前只支持到python3.4，更新不积极，而pymysql支持Python3.5。</code></pre><h3 id="怎样使用pymysql呢"><a href="#怎样使用pymysql呢" class="headerlink" title="怎样使用pymysql呢"></a>怎样使用pymysql呢</h3><pre><code>首先安装pymysql，pip install pymysql</code></pre><p>使用示例,数据库连接</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"><span class="comment">#建立一个连接</span></span><br><span class="line">con = pymysql.connect(</span><br><span class="line">        host=<span class="string">'127.0.0.1'</span>,</span><br><span class="line">        user=<span class="string">'root'</span>,</span><br><span class="line">        passwd=<span class="string">'root'</span>,</span><br><span class="line">        db=<span class="string">'somedb'</span>,</span><br><span class="line">        charset=<span class="string">'utf8'</span>,</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>
<p>更好的方法是建立一个字典来管理这些数据库连接的参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line">config = &#123;</span><br><span class="line">        <span class="string">'host'</span>:<span class="string">'127.0.0.1'</span>,</span><br><span class="line">        <span class="string">'user'</span>:<span class="string">'root'</span>,</span><br><span class="line">        <span class="string">'passwd'</span>:<span class="string">'root'</span>,</span><br><span class="line">        <span class="string">'db'</span>=<span class="string">'somedb'</span>,</span><br><span class="line">        <span class="string">'charset'</span>=<span class="string">'utf8'</span>,</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">#连接数据库</span></span><br><span class="line">conn = pymysql.connect(**config)</span><br></pre></td></tr></table></figure>
<p>插入数据：</p>
<p>执行sql语句之前要获取光标cursor，因为默认配置是自动提交的，所以在执行sql语句需要主动的commit，在最后要主动关闭连接。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line">config = &#123;</span><br><span class="line">        <span class="string">'host'</span>:<span class="string">'127.0.0.1'</span>,</span><br><span class="line">        <span class="string">'user'</span>:<span class="string">'root'</span>,</span><br><span class="line">        <span class="string">'passwd'</span>:<span class="string">'root'</span>,</span><br><span class="line">        <span class="string">'db'</span>=<span class="string">'somedb'</span>,</span><br><span class="line">        <span class="string">'charset'</span>=<span class="string">'utf8'</span>,</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">#连接数据库</span></span><br><span class="line">conn = pymysql.connect(**config)</span><br><span class="line">cur = conc.cursor()</span><br><span class="line"><span class="comment">#执行</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">with</span> cur <span class="keyword">as</span> cursor:</span><br><span class="line">        sql = <span class="string">"insert into sometable (somefield,somefield...) values (%s...)</span></span><br><span class="line"><span class="string">        cursor.excute(sql,(values...))</span></span><br><span class="line"><span class="string">    cursor.connection.commit()</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">finally:</span></span><br><span class="line"><span class="string">    cur.close()</span></span><br><span class="line"><span class="string">    conn.close()</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">执行查询：</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> pymysql.cursors</span><br><span class="line"> </span><br><span class="line"><span class="comment">#连接配置信息</span></span><br><span class="line">config = &#123;</span><br><span class="line">          <span class="string">'host'</span>:<span class="string">'127.0.0.1'</span>,</span><br><span class="line">          <span class="string">'port'</span>:<span class="number">3306</span>,</span><br><span class="line">          <span class="string">'user'</span>:<span class="string">'root'</span>,</span><br><span class="line">          <span class="string">'password'</span>:<span class="string">'zhyea.com'</span>,</span><br><span class="line">          <span class="string">'db'</span>:<span class="string">'employees'</span>,</span><br><span class="line">          <span class="string">'charset'</span>:<span class="string">'utf8mb4'</span>,</span><br><span class="line">          <span class="string">'cursorclass'</span>:pymysql.cursors.DictCursor,</span><br><span class="line">          &#125;</span><br><span class="line"><span class="comment"># 创建连接</span></span><br><span class="line">connection = pymysql.connect(**config)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 获取雇佣日期</span></span><br><span class="line">hire_start = datetime.date(<span class="number">1999</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">hire_end = datetime.date(<span class="number">2016</span>, <span class="number">12</span>, <span class="number">31</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 执行sql语句</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">with</span> connection.cursor() <span class="keyword">as</span> cursor:</span><br><span class="line">        <span class="comment"># 执行sql语句，进行查询</span></span><br><span class="line">        sql = <span class="string">'SELECT first_name, last_name, hire_date FROM employees WHERE hire_date BETWEEN %s AND %s'</span></span><br><span class="line">        cursor.execute(sql, (hire_start, hire_end))</span><br><span class="line">        <span class="comment"># 获取查询结果</span></span><br><span class="line">        result = cursor.fetchone()</span><br><span class="line">        print(result)</span><br><span class="line">    <span class="comment"># 没有设置默认自动提交，需要主动提交，以保存所执行的语句</span></span><br><span class="line">    connection.commit()</span><br><span class="line"> </span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    connection.close();</span><br></pre></td></tr></table></figure>
<p>这里是查询获取一条结果，查询的结果是以字典（dict）的形式返回的。<br>从结果集中获取指定数目的结果，可以使用fetchmany方法。</p>
<p>result = cursor.fetachmany(2)<br>获取两条结果<br>不过不建议这样使用，最好在sql语句中设置查询的记录总数。(sql查询的速度肯定要快于Python的查询速度)</p>
<p>获取全部结果集可以使用fetchall方法：</p>
<p>result = cursor.fetchall()</p>
<p>在django中使用pymysql</p>
<p>在django1.8中，用python3.x开发，在django的配置文件中配置数据库驱动</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DATABASES = &#123;</span><br><span class="line">   <span class="string">'default'</span>: &#123;</span><br><span class="line">        <span class="string">'ENGINE'</span>: <span class="string">'django.db.backends.mysql'</span>,</span><br><span class="line">        <span class="string">'NAME'</span>: <span class="string">'mytest'</span>,</span><br><span class="line">        <span class="string">'USER'</span>: <span class="string">'root'</span>,</span><br><span class="line">        <span class="string">'PASSWORD'</span>: <span class="string">'zhyea.com'</span>,</span><br><span class="line">        <span class="string">'HOST'</span>: <span class="string">'127.0.0.1'</span>,</span><br><span class="line">        <span class="string">'PORT'</span>: <span class="string">'3306'</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>注意在站点的初始化文件init.py的文件中保存以下内容：</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line">pymysql.install_as_MySQLdb()</span><br></pre></td></tr></table></figure>
<pre><code>日常注意：

在设置数据库时，为了兼容性，和防止以后出现数据的编码问题，在建立数据库，建立表，建立表的字段时，都要设置好统一的编码格式，推荐utf8mb4_unicode_ci
在使用pymysql连接数据库是，配置的连接参数charset要设置和mysql数据库的一致，这样在获取数据是就可以避免出现编码的问题。
在完成对数据库的操作的时候，一定要手动关闭连接和光标。</code></pre>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pymysql</tag>
      </tags>
  </entry>
</search>
